<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[typeof返回值]]></title>
    <url>%2F2018%2F09%2F22%2Ftypeof%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[js基本数据类型js里面基本数据类型分为原始值和引用值两大类。其中原始值包括数字number，字符串string，布尔值boolean，undefined，null五种。引用值包括数组array，对象object，函数function三种。 typeof判断数据类型当传入一个变量时，可以用typeof来判断基本的数据类型。 typeof的返回值typeof的返回值包括”number” ，”string” ，”boolean” ，”undefined” , “object” ， “function”六类 其调用形式如下：(1)typeof num(2)typeof(num)其中，typeof后面跟的为需要判断数据类型的变量。变量可以直接跟在typeof后面以空格分开，也可以直接写在括号里 看如下例子：123typeof 123; //&quot;number&quot;typeof NaN; //&quot;number&quot;typeof Infinity; //&quot;number&quot; 但凡是数学计算能产生的结果都是数字类型，数字类型的返回值为”number” 12345var str = &apos;123abc&apos;;typeof str; //&quot;string&quot; typeof +str; //&quot;number&quot;typeof !!str; //&quot;boolean&quot;typeof str + &apos;&apos;; //&quot;string&quot; 输入一个字符串，字符串可以通过运算符改变其类型 1typeof a; //&quot;undefined&quot; 在js中，一个变量未经声明就使用，只有在一种情况下不会报错，那就是将变量放在typeof里面查看类型 综上总结，可以将基本数据类型和typeof的返回值做如下对应关系：typeof的返回值: “number” ，”string” ，”boolean” ，”undefined” , “function” ，”object”“number”为数字类型(number)的返回值“string”为字符串类型(string)的返回值“boolean”为布尔值(boolean)的返回值, 布尔值包括0和1“undefined”为undefined的返回值(即值未定义)“function”为函数function的返回值比较特殊的是，”object”为null，数组array，对象object的返回值 注意点typeof的返回值均为字符串，即number类型的字符串，string类型的字符串，boolean类型的字符串，undefined类型的字符串，function类型的字符串，object类型的字符串 即typeof(typeof “number”) =&gt; “string” 特殊情况考虑以下情况，当基本数据类型的首字母大写时，相应的typeof是否也会发生改变呢？ typeof Number =&gt; “string”typeof String =&gt; “string”typeof Boolean =&gt; “string”typeof Undefined =&gt; “undefined”typeof Null =&gt; “undefined”typeof Array =&gt; “string”typeof Object =&gt; “string”typeof Function =&gt; “string” 总结起来就是返回值为”string”包括：Number / String / Boolean / Array / Object / Function返回值为”undefined”包括：Undefined / Null]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>typeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行内元素和块级元素]]></title>
    <url>%2F2018%2F09%2F21%2F%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[元素分类块级元素(block)常用元素：div / p / ul / li / ol / form / address / h(h1-h6) 特点：元素独自占据一整行，可以给元素设置宽和高 具体设置如下：12345678910111213&lt;div class=&quot;red&quot;&gt;&lt;/div&gt;&lt;div class=&quot;blue&quot;&gt;&lt;/div&gt;&lt;style&gt; div &#123; width: 100px; height: 100px; background: red; &#125; .blue &#123; background: blue; &#125;&lt;/style&gt; 在浏览器中展示如下：可以看到，第一个div的宽度只有100px, 但是他占据了浏览器的一整行。使得第二个div换行展示 行内元素(inline)常用元素：span / a / em / del / strong 特点：根据自身内容占据空间大小，不能给元素设置宽和高 具体设置如下：12&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 在浏览器中展示如下：可以看到，span根据自身的内容占据了相应的大小，后面的span紧挨着进行展示 行级元素虽然不可以设置宽高，但可以给他设置字体大小(font-size)，字体颜色(color)，字体样式(font-family)等和字体相关的属性 行级块元素(inline-block)也叫内联元素，常用元素：img / input 特点：根据自身内容占据大小，又可以给元素设置宽和高 具体设置如下：12345678910&lt;input type = &quot;text&quot;&gt;&lt;input type = &quot;text&quot;&gt;&lt;style&gt; input &#123; width: 200px; height: 30px; margin-right: 30px; &#125;&lt;/style&gt; 在浏览器中展示如下： 行级块元素input设置了宽和高，第一个input占据的宽度仅为设置的宽度，第二个input紧挨着第一个进行展示 行级块元素通常会被分类在行内元素里面 相互转换关系块级元素默认display: block 行内元素默认display: inline 行级块元素默认display: inline-block 当给块级元素设置display: inline或设置display: inline-block时，块级元素可以转换为行内元素或者行级块元素，并具有行级元素或行级块元素独有的特性。以此类推。 注意点margin和padding为复合属性，默认顺序为(上 右 下 左)。 块级元素的margin值包括(margin-top, margin-right, margin-bottom, margin-left)，padding值包括(padding-top, padding-right, padding-bottom, padding-left) 但行内元素只有margin-left, margin-right, padding-left, padding-right值 根据默认margin和padding分类只有默认margin值：body / p / form h(h1-h6) 只有默认padding值：input / img / textarea / button 有默认padding和margin：ol / ul 没有默认padding和margin：div / span body默认有8px的margin值 只有清除默认的padding和margin值我们设置的css样式才不会有偏差，样式才能布满整个页面 常用的处理方式：一般在css全局里面定义以下代码：1234* &#123; padding: 0; margin: 0;&#125; 也可以在总样式文件里面定义如下内容：1body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, textarea, p, blockquote, th, td, img &#123;padding: 0; margin: 0;&#125; 即选出css中可能用到的具有margin和padding的标签，将其初始化]]></content>
      <categories>
        <category>元素分类</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>行内元素</tag>
        <tag>块级元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组扁平化]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[你可能会看到这样一种情况，大概的描述就是一个数组里面包含了很多了数组，数组里面还可以包含数组。或者是一个数组里面包含了很多个对象。 我们通常需要的只是一维的数组，此时就需要将数组扁平化处理]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找法]]></title>
    <url>%2F2018%2F09%2F03%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分查找法二分查找法也称折半查找法，适用于在已知排列顺序的有序数组查找某个特定元素。 原理：(1)首先，从数组的中间位置开始查找。如果要查找的元素等于中间元素，返回中间元素索引。否则，进行第二步。 (2)如果要查找的元素大于中间元素，则在数组大于中间元素的那半区域进行查找； 如果要查找的元素小于中间元素，则在数组小于中间元素的那半区域进行查找。 然后重复第一步的操作。 (3)如果要查找的元素不存在，则返回-1。 具体实现12345678910111213141516171819function search (data, target) &#123; var start = 0, end = data.length - 1; while (start &lt;= end) &#123; var middle = Math.floor((start + end) / 2); //找到中间元素 if (target === data[middle]) &#123; return middle; &#125;else if (target &gt; data[middle]) &#123; start = middle + 1; &#125;else &#123; end = middle - 1; &#125; &#125; return -1; //要查找的元素不存在&#125;var arr = [1, 5, 2, 7, 13, 2, 3, 4, 34];var result = search(arr, 7); //方法调用console.log(result); //3,返回目标元素的索引]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序法]]></title>
    <url>%2F2018%2F09%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序法在看阮一峰老师的快速排序法时，总能看到网上各种各样的吐槽文章，都说阮老师的实现方法有问题。那么，具体问题到底在哪呢？ 本着学习的心态，查找了一些相关的文章和实现方法，发现大家都是不约而同的采用阮老师的实现方法。我在阮老师的基础上做了一点改进，如下。 原理(1)选基准：选择数组里面的任意一个元素作为基准数(我以中间元素为例)。 (2)划分数组： 小于基准数的元素放在’基准’左边； 大于基准数的元素放在’基准’右边； 等于基准数的元素和’基准’放在一起。 (3)递归：对’基准’左边和右边两个子集，不断重复第一步和第二步，直到所有子集只剩一个元素为止。 具体实现123456789101112131415161718192021222324252627function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; //递归出口，当数组长度小于等于1时返回 return arr; &#125; var temple = Math.floor(arr.length / 2); var flag = arr.splice(temple, 1)[0]; var left = [], middle = [flag], right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; flag) &#123; left.push(arr[i]); &#125;else if (arr[i] &gt; flag) &#123; right.push(arr[i]); &#125;else &#123; middle.push(arr[i]); &#125; &#125; return quickSort(left).concat(middle, quickSort(right));&#125;var arr = [2, 5, 23, 10, 7, 8, 12, 7, 6];var newArr = quickSort(arr);console.log(newArr); //[2, 5, 6, 7, 7, 8, 10, 12, 23] 待排序数组每次调用quickSort方法时，都会被分成左，中，右三个数组。对左边和右边的数组再用相同的方法进行排序，最后返回排序完成的数组。 相关方法：(1) Math.floor() 向下取整 temple = Math.floor(arr.length / 2); 当数组长度为偶数时，刚好取到中间左边的那位，var arr = [2, 5, 23, 10],temple == 5; 当数组长度为奇数时，刚好取到中间的那位，var arr = [2, 5, 4，23, 10],temple == 4; (2) Array.splice(start, length) 从第几位开始删除数组，删除几个长度，直接操作原数组，并返回原数组，数组中的每一项为删除的数据 (3) Array.concat(arr1, arr2, …) 多个数组arr1, arr2和数组Array进行拼接成一个数组，返回拼接完成后的数组 总结我和阮一峰老师快排的不同主要在于多了一个middle数组来接收和’基准’一样的元素。 用递归方法来实现时，需要考虑到每次进行操作时共同点在哪（即找规律，找公式）。 还要考虑到当满足一定条件时跳出（即出口），否则程序将会陷入死循环。]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序和选择排序]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[关于数组的操作，经常会涉及到时间复杂度，空间复杂度，稳定性和不稳定性几个概念。 时间复杂度：一个程序执行所需要的时间，主要针对的是for循环 空间复杂度：程序所需的存储空间，可以估算出内存的大概使用情况 稳定性：如果a = b，a在b的前面，排序后a任然在b的前面 不稳定性：如果a = b，a在b的前面，排序后a在b的后面 具体的归纳情况可以见下图： 数组的排序方法冒泡排序法原理：依次比较数组里面每相邻的两个元素。如果前面的数比后面的数大，则将两个数交换顺序。也就是找到数组的最大数放在最后一位。 重复相同的规律，每次找出剩下数组里面的最大数放在最后面，直到数组有序排列为止。 具体实现(原型链编程)：1234567891011121314151617Array.prototype.bubbleSort = function () &#123; var temple; for (var i = 0; i &lt; this.length - 1; i++) &#123; //this指向被调用的对象 for (var j = 0; j &lt; this.length - 1 - i; j++) &#123; if (this[j] &gt; this[j+1]) &#123; temple = this[j]; this[j] = this[j+1]; this[j+1] = temple; &#125; &#125; &#125; return this;&#125;var arr = [1, 5, 2, 7, 13, 2, 3, 4, 34];var arrSort = arr.bubbleSort(); //方法调用console.log(arrSort); //[1, 2, 2, 3, 4, 5, 7, 13, 34] 需要注意的是，每两个数进行比较大小时，知道第n - 1个数，则可以比较出第n - 1个数和第n个数的大小。所以第一个for循环终止条件为arr.length - 1。 第二个for循环时，当i = 0时，需要循环的次数为arr.length - 1,第一次循环结束的结果是选出最大的数放在数组最后，即排序后的数组为[1, 2, 5, 7, 2, 3, 4, 13, 34]。 当i = 1时，循环次数为arr.length - 1 - 1，即最后一个数已经确定大小，不需要比较。还有余下数组的最后一位也不需要比较。 当然啦，这样做是为了节省时间复杂度，当两圈for循环的终止条件改为arr.length也是可以的。 选择排序原理：选择排序是指选出数组里面的第一个数依次和后面的每个数作比较，如果后面的数比第一个数小，交换顺序（选出最小的数放在第一位）。 再选出第二个数依次和后面的每个数作比较，选出余下数组里面最小的放在第二位。 重复以上规律，知道数组有序为止。 具体实现：12345678910111213141516Array.prototype.selectSort = function () &#123; for (var i = 0; i &lt; this.length - 1; i++) &#123; //this指向被调用的对象 for (var j = i + 1; j &lt; this.length; j++) &#123; if (this[i] &gt; this[j]) &#123; temple = this[i]; this[i] = this[j]; this[j] = temple; &#125; &#125; &#125; return this;&#125;var arr = [1, 5, 2, 7, 13, 2, 3, 4, 34];var arrSelect = arr.selectSort(); //方法调用console.log(arrSelect); //[1, 2, 2, 3, 4, 5, 7, 13, 34] 冒泡排序和选择排序的区别比较冒泡排序和选择排序，发现他们其实实现原理都是一样的。 区别在于，冒泡排序是每两个相邻元素作比较，每次排序的结果是选出当前数组中的最大元素放在数组最后。选择排序是第一个元素依次和后面的每个元素比，选出最小的元素放在数组第一位。依次重复类推。 冒泡排序是先确定最大元素放在最后，选择排序先确定最小元素放在第一位，所以他们最终的结果都是数组里面的数升序排列。]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[数组去重数组去重是后续经常会用到以及面试中经常用到的知识点，最近在复习中整理了以下几种方法仅供大家参考。 原生方法原理：建立一个新数组，取出原数组的每一项和新数组的每一项作对比，将原数组中存在而新数组中不存在的元素添加到新数组中，最后返回新数组 具体实现（原型链上编程）：12345678910111213141516171819Array.prototype.unique = function () &#123; var newArr = [this[0]]; //谁调用的unique方法，this指向谁（arr) for (var i = 0; i &lt; this.length; i++) &#123; var flag = true; for (var j = 0; j &lt; newArr.length; j++) &#123; if (this[i] === newArr[j]) &#123; flag = false; &#125; &#125; if (flag) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 需要注意的是：1.第二个for循环遍历的次数为newArr.length，如果newArr为空，则不会进入for循环，将不会执行后面的语句。 2.第二个for循环里不能只是简单的根据条件判断arr[i] !== newArr[j]便试图直接调用newArr.push(arr[i])的方法来进行添加。 试想一下，当数组arr遍历到第3位(即1)时，此时newArr == [1, 2]，newArr.length == 2；进入第二个for循环中，循环次数为2。 第一次循环时arr[i] === newArr[j] (即1 == 1)，不会进入if循环；第二次arr[i] !== newArr[j] (即1 != 2)，进入if语句，执行push语句，所以会再次向newArr中添加1，返回newArr = [1, 2, 1],以此类推。 即以下写法是错误的：1234567for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; newArr.lenght; j++) &#123; if (arr[i] !== newArr[j]) &#123; newArr.push(arr[i]); &#125; &#125;&#125; 利用对象的属性名无重复原理：对象的属性名是没有重复的，取出数组的每一位，看对象里面是否存在（即取出对象的属性名，看对应的属性值是否存在。如果不存在，则证明对象中没有这个属性，该元素在数组中是第一次出现，并将该元素添加到新数组中）。此时需要给不存在的属性赋值做标记 具体实现：123456789101112131415Array.prototype.unique = function () &#123; var obj = &#123;&#125;; var newArr = []; for (var i = 0; i &lt; this.length; i++) &#123; if(!obj[this[i]]) &#123; obj[this[i]] = 1; newArr.push(this[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 调用splice()删除重复元素原理：取出数组中的每一个元素依次和后面的每一个元素对比，如果后面的元素有相同的则为重复元素，删除该元素 相关方法：splice(start, length) 从第几位开始删除数组，删除几个长度，直接操作原数组，并返回原数组，数组中的每一项为删除的数据 slice(start, end) 截取数组的start位到end位（但不包括end位）的值，返回一个新数组。原数组不改变 具体实现：1234567891011121314Array.prototype.unique = function () &#123; for (var i = 0; i &lt; this.length; i++) &#123; //谁调用的unique方法，this指向谁（arr) for (var j = i + 1; j &lt; this.length; j++) &#123; if (this[i] === this[j]) &#123; this.splice(j, 1); &#125; &#125; &#125; return this;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] indexOf()找出符合条件的第一个原理：根据indexOf()来判断该元素是否是第一次出现，即看当前元素的索引值是否是满足条件的第一个索引值。 相关方法：Array.indexOf(item): 返回item元素在当前数组中第一次出现的索引值，不存在则返回-1。 具体实现：123456789101112Array.prototype.unique = function () &#123; for (var i = 0; i&lt; this.length; i++) &#123; if(this.indexOf(this[i]) !== i) &#123; this.splice(i, 1); &#125; &#125; return this;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] filter()按一定规则遍历数组原理：用filter来遍历生成满足条件的新数组，判断的条件需要借助indexOf()来判断当前元素的索引是否等于当前的索引 相关方法：filter(item, index, array) 有三个参数，第一个为数组的每一项(相当于arr[i])，第二个为当前元素的索引(i)，第三个为原来的数组(即调用filter的那个数组)。 该方法会返回一个满足条件的新数组。 具体实现：12345678910Array.prototype.unique = function () &#123; var newArr = this.filter(function (item, index, array) &#123; return array.indexOf(item) === index; &#125;) return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 看到这里相信你应该已经明白，filter()方法就相当于for循环的封装，本质上还是取出数组中的当前项和当前索引，看该元素的索引值是不是第一次出现 sort()先排序，再去重原理：先将数组进行排序，相同的数据会排列在一起。 所以进行数组去重时只需要将当前数据与前一个数据作对比。如果当前数据不等于前一个数据，则说明该数据是第一次出现。 可以利用一个新数组，每次将数据添加到新数组时，通过判断当前的数据与新数组的最后一位是否相等。如果不相等，则将该数据push到新数组。 相关方法：Array.sort() 默认将数组按照ASCII进行排序。 当里面传入一个回调函数时，即Array.sort(function (a, b) {return 1;})为升序排列；当return -1时为降序排列。 具体实现：1234567891011121314Array.prototype.unique = function () &#123; this.sort(); var newArr = []; for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] !== newArr[newArr.length - 1]) &#123; newArr.push(this[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 13, 2, 3, 34, 4] 从结果可以看到，返回的数组根据ASCII升序排列。 Set()数据结构原理：调用ES6中的Set数据结构可以用于数组去重 具体实现：123var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var setArr = new Set(arr);console.log(setArr); 结果：]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历]]></title>
    <url>%2F2018%2F08%2F15%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[参考文献：https://www.cnblogs.com/attitudeY/p/6790219.html和https://blog.csdn.net/zhouziyu2011/article/details/62236006 树树状图是一种数据结构，把他叫做树是因为他像一棵倒挂的树，根朝上，叶朝下。大概结构如下：图片来源：点击查看你所看到的每个元素叫做一个节点，一棵树可以有多个节点。 特殊的是，二叉树的节点不超过两个。最上面的没有父节点的（23）称为根节点，以根节点为分界点，可以把二叉树树分为左子树和右子树，如上图。二叉树常被用于实现二叉查找树和二叉堆。 二叉树的遍历深度优先遍历对于一棵二叉树，深度优先遍历是沿着树的深度遍历树的节点层数，尽可能深的搜索树的分支，其中，每个节点只能遍历一次。 深度优先遍历分为先序遍历，中序遍历，后序遍历。先序遍历：对任意子树，先访问根，然后遍历其左子树，最后遍历右子树。中序遍历：对任意子树，先遍历其左子树，然后访问根，最后遍历右子树。后序遍历：对任意子树，先遍历其左子树，然后遍历右子树，最后访问根。 广度优先遍历广度优先遍历又叫宽度优先搜索或横向优先搜索，是从根节点开始沿着树的宽度一层层的往下遍历，在每一层中，从左往右（或从右往左）访问每一个节点，访问完一层就进入下一层，直到找到最后一层。 请看下面例子：先序遍历：35 20 15 16 29 28 30 40 50 45 55中序遍历：15 16 20 28 29 30 35 40 45 50 55后序遍历：16 15 28 30 29 20 45 55 50 40 35广度优先遍历：35 20 40 15 29 50 16 28 30 45 55 深度优先和广度优先的区别深度优先：二叉树的深度优先遍历采用的是栈。深度优先遍历二叉树是先访问根节点，然后访问左子树，接着访问右子树。根据栈先进后出的原则，我们可以先将右子树压栈，然后将左子树压栈，这样左子树就位于栈顶，可以永远保证左子树先于右子树被访问到。 深度优先搜索不全部保留节点，拓展完的节点从数据库中弹出删去。这样，一般在数据库中存储的节点就是深度值，因此他占用空间少。适用于搜索树节点较多时。 广度优先：广度优先遍历采用的是队列。一般需存储产生的所有节点，占用的存储空间比深度优先搜索大的多。因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先算法没有出栈入栈的操作，运行速度比深度优先搜索快。 算法实现深度优先遍历递归实现123456789101112function dfs (node) &#123; var nodes = []; if (node !== null) &#123; nodes.push(node); var children = node.children; var len = children.length; for (var i = 0; i &lt; len; i++) &#123; dfs(children[i]); &#125; &#125; return nodes;&#125; 深度优先遍历非递归实现1234567891011121314151617function dfs (node) &#123; var nodes = []; if (node !== null) &#123; var stack = []; stack.push(node); while (stack.length !== 0) &#123; var item = stack.pop(); nodes.push(item); var children = item.children; var len = children.length; for (var i = len - 1; i &gt;= 0; i--) &#123; stack.push(children[i]); &#125; &#125; &#125; return nodes;&#125; 广度优先遍历递归实现1234567891011function bfs(node) &#123; var nodes = []; var i = 0; if (!(node == null)) &#123; nodes.push(node); bfs(node.nextElementSibling); node = nodes[i++]; bfs(node.firstElementChild); &#125; return nodes;&#125; 广度优先遍历非递归实现123456789101112131415function bfs(selectNode) &#123; var nodes = []; if (selectNode != null) &#123; var queue = []; queue.unshift(selectNode); while (queue.length != 0) &#123; var item = queue.shift(); nodes.push(item); var children = item.children; for (var i = 0; i &lt; children.length; i++) queue.push(children[i]); &#125; &#125; return nodes;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构，二叉树，深度优先，广度优先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮动]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[我曾经遇到过这样一个面试题，a和b为兄弟结构标签，c为a的子标签，当a标签的z-index为1，b为2，c为3时，页面该如何布局。12345678910111213141516171819202122232425&lt;div class=&apos;a&apos;&gt; &lt;div class=&apos;c&apos;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;b&apos;&gt;&lt;/div&gt;&lt;style&gt; .a, .b &#123; width: 200px; height: 200px; &#125; .a &#123; z-index: 1; background: green; &#125; .b &#123; z-index: 2; background: blue; &#125; .c &#123; z-index: 3; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 你想到该如何布局了吗？跟浮动不一样的是，z-index只是将元素抽离到更高层面进行定位，并不会影响到他原来的布局。z-index默认值为0，当多个元素具有z-index属性时，数字越大的显示时越在上面。W3C 对 z-index 属性的描述中提到在 z-index 属性仅在节点的 position 属性为 relative, absolute 或者 fixed 时生效。 浏览器实际展示效果如下：div为块级元素，独自占据一整行，所以a和b在不同的行显示，c为a的子级，a将包裹着c,但是c的z-index的值大于a,所以c显示在最上面 想象一下，在三维坐标轴中，z轴代表物体的高度，当给物体加上z-index属性时，物体就具有了空间感，就能根据z-index对物体进行定位。 对于同样的标签，当给他设置的是浮动属性而不是z-index时，将会发生什么呢？同样的，改变z-index为float，代码如下：12345678910111213141516171819202122232425&lt;div class=&apos;a&apos;&gt; &lt;div class=&apos;c&apos;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;b&apos;&gt;&lt;/div&gt;&lt;style&gt; .a, .b &#123; width: 200px; height: 200px; &#125; .a &#123; float: left; background: green; &#125; .b &#123; float: left; background: blue; &#125; .c &#123; float: left; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 具有浮动属性的元素将会脱离正常的文档流，被抽离到更高层面进行定位，所以a和b并排在一起，a里面包裹着他的子元素c。]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>浮动</tag>
        <tag>z-index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于元素的bfc]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%85%B3%E4%BA%8Ebfc%E5%8F%8A%E7%94%A8%E9%80%94%2F</url>
    <content type="text"><![CDATA[bfc–块级格式化上下文具有bfc特性的元素可以看做是隔离了的独立容器。容器里面的元素无论怎样变化，都不会在布局上影响到外面的元素，并具有普通元素没有的特性。 能够触发bfc特性的以下任意一个条件均能触发元素的bfc属性：(1)float: left / right(除none);(2)overflow: hidden / auto / scroll(除visible);(3)position: absolute / fixed;(4)display: inline-block / flex / inline-flex / table-cell /table-caption;(5)根标签body; bfc的用途I.清除浮动当给子级元素设置浮动属性时，需要给父级清除浮动。浏览器呈现的情况如下：代码如下：1234567891011121314151617181920&lt;div class=&apos;wrapper&apos;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; background: green; border: 2px solid #000; margin-top: 200px; &#125; .wrapper div &#123; float: left; margin: 30px; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 可以看到，父级包不住子级的div元素，需要给父级清除浮动触发父级的bfc，使其回到正常的文档流。 清除浮动的方法：123456789101112131415161718192021&lt;div class=&apos;wrapper&apos;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; display: inline-block; background: green; border: 2px solid #000; margin-top: 200px; &#125; .wrapper div &#123; float: left; margin: 30px; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 清除浮动后的样式:这里是通过给父级添加属性’display: inline-block’来实现，你也可以通过其他方法试一试。 II.解决margin塌陷请看下面情况：此时明明给父级和子级都设置了margin-top，但是浏览器所展现出来的只有父级的margin-top。 代码如下：123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 150px; height: 150px; background: orange; &#125;&lt;/style&gt; 这里涉及到盒子模型的概念。盒子模型的组成包括margin + border + padding + content。其中，在此提到的margin为复合属性，包括margin-top, margin-right, margin-bottom, margin-left。浏览器后台的盒子模型如下： margin塌陷指的是margin-top，针对的是具有父子结构嵌套的元素。 解决margin塌陷的方法1如果想要父级子级的margin-top都能正常的显示，此时只需要触发父级元素的bfc属性。12345678910111213141516171819&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; overflow: hidden; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 150px; height: 150px; background: orange; &#125;&lt;/style&gt; 修改后的展示如下： 上面是通过给父级添加overflow: hidden的属性来实现的，用overflow: hidden的缺点就是：如果子级元素大于父级元素时，子级多出父级元素的部分会被隐藏。 当子级溢出部分没有被隐藏时，实际展示效果如下： 此时和上面不同的只是使子级元素的宽度大于父级，多出的部分会超出父级正常显示。123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 给父级设置overflow：hidden属性后，浏览器显示如下：相应代码如下：12345678910111213141516171819&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; overflow: hidden; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 此时虽然能解决margin塌陷带来的坏处，但是却使子级多出父级的部分溢出隐藏，如果想要使子级多出的部分正常显示，就可以采取其他的方法来触发元素的bfc属性。 解决margin塌陷的方法2通过计算解决：当子级元素的margin-top大于父级时，实际展示效果将以子级的margin-top为准，子级会带动父级一起向下运动。123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 300px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 以上代码通过计算来解决margin塌陷，实际上在浏览器中最终所展示的margin-top为300px,而且不会影响到子级元素的大小。]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>bfc</tag>
        <tag>浮动</tag>
        <tag>margin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello MyBlog]]></title>
    <url>%2F2018%2F07%2F08%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[这是我搭建好博客后的第一篇文章，一切都会有个好的开始。 我是一个前端的小菜鸟，可能很多东西理解的也不太对，欢迎大家留言指正。 搭建博客博客基础这里主要借助的是 GitHub + Hexo 来进行搭建博客。可能你也像我一样是技术小白，可能你也正为如何搭建博客而烦恼，如果你想新建属于自己的博客，点击 这里 查看。 博客主题样式配置如果你想更换博客主题,配置自己喜欢的样式,点击 这里 查看。 上传本地博客相信看到这里的你已经按照以上的步骤配置好了属于自己的博客,此时博客只是在本地运行的,想要让本地博客能在浏览器里访问，快借助GitHub来进行配置吧！主要方法(在cmd工具栏中进入搭建博客的本地文件夹，输入如下命令)：1$ hexo g 1$ hexo d 具体可以参照 这里 来进行配置！ 新建文章新建页面配置好所有的环境之后，就可以在本地编辑器里写自己的博客内容了。首先，当然是要新建博客写作页面了。在hexo里面有三种新建的方式。在cmd里执行以下命令：1$ hexo new [layout] &lt;title&gt; 其中，layout为新建的位置，包含以下三个值：布局—————-路径post—————source/_posts (一般新建单个博客页面时使用)page—————source (用来配置和引入资源,包括图片,以及在搭建博客时的标签,分类页)draft—————source/_drafts (新建草稿)举个栗子:1$ hexo new post hello,hexo 1$ hexo new page tags 现在，你可以找到source文件夹查看具体区别。 配置参数每新建好一个文件，你可以看到最上面有用--- ---来隔开一个部分，这是用来进行参数匹配的。 在本篇博客里，我的配置是这样的：1234567---title: Hello MyBlogdate: 2018-07-08 09:58:00tags: [hexo,blog,essay]categories: 搭建博客comments: true--- 其中，tags和categories参数你需要先建立页面1$ hexo new page tags 1$ hexo new page categories 并在source文件夹下找到对应的tags页面，配置以下参数：12345---title: tagsdate: 2018-07-07 13:23:03type: &apos;tags&apos;--- 同理，在categories页面中配置：12345---title: categoriesdate: 2018-07-08 21:21:28type: &apos;categories&apos;--- 到这里，页面基本参数就配置好了，接下来主要就是要发布的博客内容。 文章标题一级标题：&lt;h1&gt;&lt;/h1&gt; –表示方法：# 名称二级标题：&lt;h2&gt;&lt;/h2&gt; –表示方法：## 名称三级标题：&lt;h3&gt;&lt;/h3&gt; –表示方法：### 名称一般我们标题都是用来语义化表示题目内容的，不宜嵌套太深，主要常用的就是前三级标题 网址链接表示方式：1[要显示的内容](与该内容相关的网址) 1[这里](https://www.jianshu.com/p/9d1b865217a5) 其他内容就正常书写就好啦！ 上传博客内容写到这里本篇博客内容页该结束啦！此时想要把本地写好的博客内容上传到浏览器里查看，只要执行以下代码就可以啦！开心~~~12$ hexo g$ hexo d 具体内容可以点击 这里 查看hexo官方文档]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
