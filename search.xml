<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[数组去重原生方法原理：建立一个新数组，取出原数组的每一项和新数组的每一项作对比，将原数组中存在而新数组中不存在的元素添加到新数组中，最后返回新数组 具体实现（原型链上编程）：12345678910111213141516171819Array.prototype.unique = function () &#123; var newArr = [this[0]]; //谁调用的unique方法，this指向谁（arr) for (var i = 0; i &lt; this.length; i++) &#123; var flag = true; for (var j = 0; j &lt; newArr.length; j++) &#123; if (this[i] === newArr[j]) &#123; flag = false; &#125; &#125; if (flag) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 需要注意的是：1.第二个for循环遍历的次数为newArr.length，如果newArr为空，则不会进入for循环，将不会执行后面的语句。 2.第二个for循环里不能只是简单的根据条件判断arr[i] !== newArr[j]便试图直接调用newArr.push(arr[i])的方法来进行添加。试想一下，当数组arr遍历到第3位(即1)时，此时newArr == [1, 2]，newArr.length == 2；进入第二个for循环中，循环次数为2。第一次循环时arr[i] === newArr[j] (即1 == 1)，不会进入if循环；第二次arr[i] !== newArr[j] (即1 != 2)，进入if语句，执行push语句，所以会再次向newArr中添加1，返回newArr = [1, 2, 1],以此类推。 即以下写法是错误的：1234567for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; newArr.lenght; j++) &#123; if (arr[i] !== newArr[j]) &#123; newArr.push(arr[i]); &#125; &#125;&#125; 利用对象的属性名无重复原理：对象的属性名是没有重复的，取出数组的每一位，看对象里面是否存在（即取出对象的属性名，看对应的属性值是否存在。如果不存在，则证明对象中没有这个属性，该元素在数组中是第一次出现，并将该元素添加到新数组中）。此时需要给不存在的属性赋值做标记具体实现：123456789101112131415Array.prototype.unique = function () &#123; var obj = &#123;&#125;; var newArr = []; for (var i = 0; i &lt; this.length; i++) &#123; if(!obj[this[i]]) &#123; obj[this[i]] = 1; newArr.push(this[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 调用splice()删除重复元素原理：取出数组中的每一个元素依次和后面的每一个元素对比，如果后面的元素有相同的则为重复元素，删除该元素相关方法：splice(start, length)从第几位开始删除数组，删除几个长度，直接操作原数组slice(start, end)截取数组的start位到end位（但不包括end位）的值，返回一个新数组。原数组不改变 具体实现：1234567891011121314Array.prototype.unique = function () &#123; for (var i = 0; i &lt; this.length; i++) &#123; //谁调用的unique方法，this指向谁（arr) for (var j = i + 1; j &lt; this.length; j++) &#123; if (this[i] === this[j]) &#123; this.splice(j, 1); &#125; &#125; &#125; return this;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] indexOf()找出符合条件的第一个原理：根据indexOf()来判断该元素是否是第一次出现，即看当前元素的索引值是否是满足条件的第一个索引值。相关方法：Array.indexOf(item): 返回item元素在当前数组中第一次出现的索引值，不存在则返回-1。 具体实现：123456789101112Array.prototype.unique = function () &#123; for (var i = 0; i&lt; this.length; i++) &#123; if(this.indexOf(this[i]) !== i) &#123; this.splice(i, 1); &#125; &#125; return this;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] filter()按一定规则遍历数组原理：用filter来遍历生成满足条件的新数组，判断的条件需要借助indexOf()来判断当前元素的索引是否等于当前的索引方法：filter(item, index, array)有三个参数，第一个为数组的每一项(相当于arr[i])，第二个为当前元素的索引(i)，第三个为原来的数组(即调用filter的那个数组)。该方法会返回一个满足条件的新数组。 具体实现：12345678910Array.prototype.unique = function () &#123; var newArr = this.filter(function (item, index, array) &#123; return array.indexOf(item) === index; &#125;) return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] Set()数据结构原理：调用ES6中的Set数据结构可以用于数组去重具体实现：123var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var setArr = new Set(arr);console.log(setArr); 结果：]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历]]></title>
    <url>%2F2018%2F08%2F15%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[参考文献：https://www.cnblogs.com/attitudeY/p/6790219.html和https://blog.csdn.net/zhouziyu2011/article/details/62236006 树树状图是一种数据结构，把他叫做树是因为他像一棵倒挂的树，根朝上，叶朝下。大概结构如下：图片来源：点击查看你所看到的每个元素叫做一个节点，一棵树可以有多个节点。 特殊的是，二叉树的节点不超过两个。最上面的没有父节点的（23）称为根节点，以根节点为分界点，可以把二叉树树分为左子树和右子树，如上图。二叉树常被用于实现二叉查找树和二叉堆。 二叉树的遍历深度优先遍历对于一棵二叉树，深度优先遍历是沿着树的深度遍历树的节点层数，尽可能深的搜索树的分支，其中，每个节点只能遍历一次。 深度优先遍历分为先序遍历，中序遍历，后序遍历。先序遍历：对任意子树，先访问根，然后遍历其左子树，最后遍历右子树。中序遍历：对任意子树，先遍历其左子树，然后访问根，最后遍历右子树。后序遍历：对任意子树，先遍历其左子树，然后遍历右子树，最后访问根。 广度优先遍历广度优先遍历又叫宽度优先搜索或横向优先搜索，是从根节点开始沿着树的宽度一层层的往下遍历，在每一层中，从左往右（或从右往左）访问每一个节点，访问完一层就进入下一层，直到找到最后一层。 请看下面例子：先序遍历：35 20 15 16 29 28 30 40 50 45 55中序遍历：15 16 20 28 29 30 35 40 45 50 55后序遍历：16 15 28 30 29 20 45 55 50 40 35广度优先遍历：35 20 40 15 29 50 16 28 30 45 55 深度优先和广度优先的区别深度优先：二叉树的深度优先遍历采用的是栈。深度优先遍历二叉树是先访问根节点，然后访问左子树，接着访问右子树。根据栈先进后出的原则，我们可以先将右子树压栈，然后将左子树压栈，这样左子树就位于栈顶，可以永远保证左子树先于右子树被访问到。 深度优先搜索不全部保留节点，拓展完的节点从数据库中弹出删去。这样，一般在数据库中存储的节点就是深度值，因此他占用空间少。适用于搜索树节点较多时。 广度优先：广度优先遍历采用的是队列。一般需存储产生的所有节点，占用的存储空间比深度优先搜索大的多。因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先算法没有出栈入栈的操作，运行速度比深度优先搜索快。 算法实现深度优先遍历递归实现123456789101112function dfs (node) &#123; var nodes = []; if (node !== null) &#123; nodes.push(node); var children = node.children; var len = children.length; for (var i = 0; i &lt; len; i++) &#123; dfs(children[i]); &#125; &#125; return nodes;&#125; 深度优先遍历非递归实现1234567891011121314151617function dfs (node) &#123; var nodes = []; if (node !== null) &#123; var stack = []; stack.push(node); while (stack.length !== 0) &#123; var item = stack.pop(); nodes.push(item); var children = item.children; var len = children.length; for (var i = len - 1; i &gt;= 0; i--) &#123; stack.push(children[i]); &#125; &#125; &#125; return nodes;&#125; 广度优先遍历递归实现1234567891011function bfs(node) &#123; var nodes = []; var i = 0; if (!(node == null)) &#123; nodes.push(node); bfs(node.nextElementSibling); node = nodes[i++]; bfs(node.firstElementChild); &#125; return nodes;&#125; 广度优先遍历非递归实现123456789101112131415function bfs(selectNode) &#123; var nodes = []; if (selectNode != null) &#123; var queue = []; queue.unshift(selectNode); while (queue.length != 0) &#123; var item = queue.shift(); nodes.push(item); var children = item.children; for (var i = 0; i &lt; children.length; i++) queue.push(children[i]); &#125; &#125; return nodes;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构，二叉树，深度优先，广度优先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮动]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[我曾经遇到过这样一个面试题，a和b为兄弟结构标签，c为a的子标签，当a标签的z-index为1，b为2，c为3时，页面该如何布局。12345678910111213141516171819202122232425&lt;div class=&apos;a&apos;&gt; &lt;div class=&apos;c&apos;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;b&apos;&gt;&lt;/div&gt;&lt;style&gt; .a, .b &#123; width: 200px; height: 200px; &#125; .a &#123; z-index: 1; background: green; &#125; .b &#123; z-index: 2; background: blue; &#125; .c &#123; z-index: 3; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 你想到该如何布局了吗？跟浮动不一样的是，z-index只是将元素抽离到更高层面进行定位，并不会影响到他原来的布局。z-index默认值为0，当多个元素具有z-index属性时，数字越大的显示时越在上面。W3C 对 z-index 属性的描述中提到在 z-index 属性仅在节点的 position 属性为 relative, absolute 或者 fixed 时生效。 浏览器实际展示效果如下：div为块级元素，独自占据一整行，所以a和b在不同的行显示，c为a的子级，a将包裹着c,但是c的z-index的值大于a,所以c显示在最上面 想象一下，在三维坐标轴中，z轴代表物体的高度，当给物体加上z-index属性时，物体就具有了空间感，就能根据z-index对物体进行定位。 对于同样的标签，当给他设置的是浮动属性而不是z-index时，将会发生什么呢？同样的，改变z-index为float，代码如下：12345678910111213141516171819202122232425&lt;div class=&apos;a&apos;&gt; &lt;div class=&apos;c&apos;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;b&apos;&gt;&lt;/div&gt;&lt;style&gt; .a, .b &#123; width: 200px; height: 200px; &#125; .a &#123; float: left; background: green; &#125; .b &#123; float: left; background: blue; &#125; .c &#123; float: left; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 具有浮动属性的元素将会脱离正常的文档流，被抽离到更高层面进行定位，所以a和b并排在一起，a里面包裹着他的子元素c。]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>浮动</tag>
        <tag>z-index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于元素的bfc]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%85%B3%E4%BA%8Ebfc%E5%8F%8A%E7%94%A8%E9%80%94%2F</url>
    <content type="text"><![CDATA[bfc–块级格式化上下文具有bfc特性的元素可以看做是隔离了的独立容器。容器里面的元素无论怎样变化，都不会在布局上影响到外面的元素，并具有普通元素没有的特性。 能够触发bfc特性的以下任意一个条件均能触发元素的bfc属性：(1)float: left / right(除none);(2)overflow: hidden / auto / scroll(除visible);(3)position: absolute / fixed;(4)display: inline-block / flex / inline-flex / table-cell /table-caption;(5)根标签body; bfc的用途I.清除浮动当给子级元素设置浮动属性时，需要给父级清除浮动。浏览器呈现的情况如下：代码如下：1234567891011121314151617181920&lt;div class=&apos;wrapper&apos;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; background: green; border: 2px solid #000; margin-top: 200px; &#125; .wrapper div &#123; float: left; margin: 30px; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 可以看到，父级包不住子级的div元素，需要给父级清除浮动触发父级的bfc，使其回到正常的文档流。 清除浮动的方法：123456789101112131415161718192021&lt;div class=&apos;wrapper&apos;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; display: inline-block; background: green; border: 2px solid #000; margin-top: 200px; &#125; .wrapper div &#123; float: left; margin: 30px; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 清除浮动后的样式:这里是通过给父级添加属性’display: inline-block’来实现，你也可以通过其他方法试一试。 II.解决margin塌陷请看下面情况：此时明明给父级和子级都设置了margin-top，但是浏览器所展现出来的只有父级的margin-top。 代码如下：123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 150px; height: 150px; background: orange; &#125;&lt;/style&gt; 这里涉及到盒子模型的概念。盒子模型的组成包括margin + border + padding + content。其中，在此提到的margin为复合属性，包括margin-top, margin-right, margin-bottom, margin-left。浏览器后台的盒子模型如下： margin塌陷指的是margin-top，针对的是具有父子结构嵌套的元素。 解决margin塌陷的方法1如果想要父级子级的margin-top都能正常的显示，此时只需要触发父级元素的bfc属性。12345678910111213141516171819&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; overflow: hidden; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 150px; height: 150px; background: orange; &#125;&lt;/style&gt; 修改后的展示如下： 上面是通过给父级添加overflow: hidden的属性来实现的，用overflow: hidden的缺点就是：如果子级元素大于父级元素时，子级多出父级元素的部分会被隐藏。 当子级溢出部分没有被隐藏时，实际展示效果如下： 此时和上面不同的只是使子级元素的宽度大于父级，多出的部分会超出父级正常显示。123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 给父级设置overflow：hidden属性后，浏览器显示如下：相应代码如下：12345678910111213141516171819&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; overflow: hidden; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 此时虽然能解决margin塌陷带来的坏处，但是却使子级多出父级的部分溢出隐藏，如果想要使子级多出的部分正常显示，就可以采取其他的方法来触发元素的bfc属性。 解决margin塌陷的方法2通过计算解决：当子级元素的margin-top大于父级时，实际展示效果将以子级的margin-top为准，子级会带动父级一起向下运动。123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 300px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 以上代码通过计算来解决margin塌陷，实际上在浏览器中最终所展示的margin-top为300px,而且不会影响到子级元素的大小。]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>bfc</tag>
        <tag>浮动</tag>
        <tag>margin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用算法]]></title>
    <url>%2F2018%2F08%2F12%2F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[##二分法适用于有序数组 已知排列顺序的数组和待查找的数据function dichotomy (target, arr) { var first = 0; var len = arr.length; var last = len - 1; while (first &lt;= last) { var middle = (len % 2) === 0 ? Math.ceil(len /2) : len /2; if (target &gt; arr[middle]) { last = middle - 1; } else if (target &lt; arr[middle]) { first = middle + 1; } else{ return middle; } } return -1; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello MyBlog]]></title>
    <url>%2F2018%2F07%2F08%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[这是我搭建好博客后的第一篇文章，一切都会有个好的开始。 我是一个前端的小菜鸟，可能很多东西理解的也不太对，欢迎大家留言指正。 搭建博客博客基础这里主要借助的是 GitHub + Hexo 来进行搭建博客。可能你也像我一样是技术小白，可能你也正为如何搭建博客而烦恼，如果你想新建属于自己的博客，点击 这里 查看。 博客主题样式配置如果你想更换博客主题,配置自己喜欢的样式,点击 这里 查看。 上传本地博客相信看到这里的你已经按照以上的步骤配置好了属于自己的博客,此时博客只是在本地运行的,想要让本地博客能在浏览器里访问，快借助GitHub来进行配置吧！主要方法(在cmd工具栏中进入搭建博客的本地文件夹，输入如下命令)：1$ hexo g 1$ hexo d 具体可以参照 这里 来进行配置！ 新建文章新建页面配置好所有的环境之后，就可以在本地编辑器里写自己的博客内容了。首先，当然是要新建博客写作页面了。在hexo里面有三种新建的方式。在cmd里执行以下命令：1$ hexo new [layout] &lt;title&gt; 其中，layout为新建的位置，包含以下三个值：布局—————-路径post—————source/_posts (一般新建单个博客页面时使用)page—————source (用来配置和引入资源,包括图片,以及在搭建博客时的标签,分类页)draft—————source/_drafts (新建草稿)举个栗子:1$ hexo new post hello,hexo 1$ hexo new page tags 现在，你可以找到source文件夹查看具体区别。 配置参数每新建好一个文件，你可以看到最上面有用--- ---来隔开一个部分，这是用来进行参数匹配的。 在本篇博客里，我的配置是这样的：1234567---title: Hello MyBlogdate: 2018-07-08 09:58:00tags: [hexo,blog,essay]categories: 搭建博客comments: true--- 其中，tags和categories参数你需要先建立页面1$ hexo new page tags 1$ hexo new page categories 并在source文件夹下找到对应的tags页面，配置以下参数：12345---title: tagsdate: 2018-07-07 13:23:03type: &apos;tags&apos;--- 同理，在categories页面中配置：12345---title: categoriesdate: 2018-07-08 21:21:28type: &apos;categories&apos;--- 到这里，页面基本参数就配置好了，接下来主要就是要发布的博客内容。 文章标题一级标题：&lt;h1&gt;&lt;/h1&gt; –表示方法：# 名称二级标题：&lt;h2&gt;&lt;/h2&gt; –表示方法：## 名称三级标题：&lt;h3&gt;&lt;/h3&gt; –表示方法：### 名称一般我们标题都是用来语义化表示题目内容的，不宜嵌套太深，主要常用的就是前三级标题 网址链接表示方式：1[要显示的内容](与该内容相关的网址) 1[这里](https://www.jianshu.com/p/9d1b865217a5) 其他内容就正常书写就好啦！ 上传博客内容写到这里本篇博客内容页该结束啦！此时想要把本地写好的博客内容上传到浏览器里查看，只要执行以下代码就可以啦！开心~~~12$ hexo g$ hexo d 具体内容可以点击 这里 查看hexo官方文档]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
