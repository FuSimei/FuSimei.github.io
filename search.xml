<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[笔试易错题整理]]></title>
    <url>%2F2018%2F10%2F08%2F%E7%AC%94%E8%AF%95%E6%98%93%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[答笔试题就像是一个翻山越岭的过程，迈过了大坑又迈小坑，很多时候以为自己跨过重重险阻终于要成功时，却一不小心就入了出题者的坑。 下面是我整理的一些面试中我遇到的易错题，有的问题我也不是特别清楚，欢迎大家各抒己见。 写出下面程序的运行结果(1)函数的执行环境123456789101112131415var str = &apos;hello&apos;;var fn1 = function () &#123; console.log(str); //HELLO&#125;str = &apos;HELLO&apos;;var fn2 = function () &#123; var str = &apos;world&apos;; fn1(); str = &apos;WORLD&apos;;&#125; fn2(); 函数能访问到变量的作用域和函数定义时的环境有关。与函数执行环境无关(只有函数中函数this时，才需要注意函数的执行环境)。 函数fn1是在全局定义的，且定义时函数内部并没有定义变量，他能访问到的变量的作用域是全局window下的。 (2)定时器问题12345678let message = &quot;Hi&quot;;let start = new Date();wait = (message) =&gt; &#123; setTimeout(() =&gt; console.log(message), 1000);&#125;wait(&quot;Hello&quot;);while (new Date() - start &lt; 1000) &#123;&#125;;console.log(&quot;Tom&quot;); 输出结果： (3)数组的复制及清空123456789var a = [6, 7, 8];var b = a; //[6, 7, 8](function (x) &#123; x.length = 0; //[],把数组a清空 x.push(2, 3, 4, 5);&#125;(a))console.log(a); //[2, 3, 4, 5]console.log(b); //[2, 3, 4, 5] 数组存在栈里，复制时，复制的是引用值的地址。当一个值发生改变时，另外一个值也会发生改变。x.length = 0可以将数组清空为空数组。 (4)闭包123456789101112function func () &#123; var i = 0; return function () &#123; console.log(i++); &#125;&#125;var func1 = func(), func2 = func();func1(); //0func1(); //1func2(); //0 考察闭包。一个函数(func)的执行结果是返回另外一个函数(return function ())，返回出去的函数任然能访问到原来的作用域链(变量i)。 func1和func2保存的都为func的执行结果，即返回出去的函数return function，func1和func2互不影响。 func1()执行时，第一次访问到的i为函数func里面声明的变量i。第二次执行时，访问到的i为第一次func1()的执行结果，即i++。 需要注意前置++和后置++的执行顺序，前置++为先++再输出，后置++为先输出后++。这里如果改为console.log(i++);输出顺序应该是1, 2, 1 (5)类似考察闭包的还有：1234567891011121314function f1 () &#123; var n = 99; add = function () &#123; n += 1; &#125; function f2 () &#123; console.log(n); &#125; return f2;&#125;var result = f1();result(); //99add();result(); //100 函数f1()的执行结果是返回f2，f2任能访问到原来的作用域链。add执行时与执行环境无关，看原来的定义环境，能访问到i。所以第二次result()的执行结果为add()执行后的i (6)定时器里的闭包123456789101112let i = 0;var j = 0;var k = 0;for(; i &lt; 10, j &lt; 6; i++, j++) &#123; setTimeout(() =&gt; &#123; k = i + j; console.log(i, j, k) &#125;, 0)&#125;setTimeout(() =&gt; &#123; console.log(k)&#125;, 100) ！！！！当for循环和定时器(异步操作)联系在一起时，一定要考虑到闭包问题。 for循环每次的执行结果是返回一个定时器setTimeout()。当j == 6时，是for循环终止的条件，此时i == j == 6;k = i + j。访问到的i, k, j都是满足for循环终止条件的最后一次的值。 输出结果： (7)关于this指向1234567891011121314151617181920var id = 21;var obj = &#123; id: 22&#125;function fn1 () &#123; setTimeout(function () &#123; console.log(this.id); &#125;)&#125;fn1(); //21fn1.call(obj); //21function fn2 () &#123; setTimeout(() =&gt; &#123; console.log(this.id); &#125;)&#125;fn2(); //21fn2.call(obj); //22 关于this指向，call()第一个参数用来改变this指向，后面的值为实参。 (8)全局环境下的this123456789101112function foo (num) &#123; console.log(num); console.log(&apos;foo&apos;, this.count++);&#125;foo.count = 0;for (var i = 0; i &lt; 8; i++) &#123; if(i &gt; 3) &#123; foo(i); &#125;&#125;console.log(&apos;win&apos;, this.count); 函数foo()执行时是在for循环里即全局window下执行的，此时this指向window。this.count =&gt; window.count，用window.count的方式访问一个全局没有声明的变量时，会把该变量当做全局window的属性挂载到全局window下，此时访问该变量的值为undefined。 ++默认会有隐式转换，即把变量转换为数字类型再进行计算，此时undefined =&gt; NaN，所以打印出的this.count为NaN. this.count一共经历的转换过程为：this.count =&gt; window.count =&gt; undefined =&gt; NaN. 执行结果： 当变量在全局已经声明时：1234567891011121314var count = 0;function foo (num) &#123; console.log(num); console.log(&apos;foo&apos;, this.count++);&#125;foo.count = 0;for (var i = 0; i &lt; 8; i++) &#123; if(i &gt; 3) &#123; foo(i); &#125;&#125;console.log(&apos;win&apos;, this.count); 用window.count的方式访问一个全局已经声明的变量时，window.count =&gt; count，此时直接找到count的值进行相应计算即可。 执行结果： (9)对象的解构赋值及原型链1234567let x = &#123;a: 3&#125;;let obj = &#123; __proto__: null, b: 2, ...x &#125;console.log(obj); 输出结果如下： (10)数组的解构赋值1234let [x, y, ...z] = [&apos;a&apos;];console.log(x); //aconsole.log(y); //undefinedconsole.log(z); //[] (11)函数执行时的预编译123456var b = 3;(function () &#123; b = 4; var b = 5;&#125;)();console.log(b); //3 在全局作用域声明b = 3;在函数里面也声明了b, 根据函数的执行顺序，声明b时，其值为undefined。当b = 4时，会在函数里面查找是否声明过变量b,如果声明过，则将函数里面b的值由undefined转换为4。 这并不是通常所说的在函数里面没有var则代表隐式声明全局作用域b。当函数里面没有声明过b时，则为隐式声明全局变量b。如下： 123456var b = 3;(function () &#123; b = 4; var c = 5;&#125;)();console.log(b); //4 (12)预编译和逻辑运算符123456789101112131415var foo = &apos;hello&apos;;(function () &#123; var foo = foo || &apos;world&apos;; console.log(foo); //world&#125;)();(function (fn) &#123; var foo = fn || &apos;world&apos;; console.log(foo); //hello&#125;)(foo);(function () &#123; console.log(foo); //undefined var foo = foo || &apos;world&apos;;&#125;)(); 此题与函数执行时查找变量的顺序有关。(1) || (2)找到真为止，(1)为假时，继续执行(2), 并把(2)的计算结果输出。]]></content>
      <categories>
        <category>易错点整理</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平垂直居中对齐]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[实现元素的水平垂直居中对齐是页面布局中很常用的一种方法。一般要实现垂直居中的元素可以是文字，某个块级元素，或者是图片。 行级元素的居中水平居中1234567891011&lt;div class=&quot;wrapper&quot;&gt; &lt;span&gt;要设置的文字&lt;/span&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; width: 300px; border: 1px solid black; text-align: center; &#125;&lt;/style&gt; 要居中的元素包在块级父层元素内，设置父级text-align: center;行级块元素也可以水平居中(img，input)。 垂直居中123456789101112&lt;div class=&quot;wrapper&quot;&gt; &lt;span&gt;要设置的文字&lt;/span&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; width: 300px; height: 100px; border: 1px solid black; line-height: 100px; &#125;&lt;/style&gt; 此方法通过给父级(或元素本身)设置line-height等于父级的高度来实现元素的垂直居中。适用于父级高度已知时，给单行文本设置垂直居中。img标签不适用此方法。 水平垂直居中12345678910111213&lt;div class=&quot;wrapper&quot;&gt; &lt;span&gt;要设置的文字&lt;/span&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; width: 300px; height: 100px; border: 1px solid black; line-height: 100px; text-align: center; &#125;&lt;/style&gt; 父级高度已知的单行文本设置水平垂直居中，通过text-align: center;和line-height等于父级高度来实现。 块级元素的居中水平居中(1)适用于单个块级元素，当左右边距设置为auto时可以设置水平居中12345678910&lt;div&gt;&lt;/div&gt;&lt;style&gt; div &#123; width: 100px; height: 100px; border: 1px solid black; margin: 0 auto; &#125;&lt;/style&gt; (2)设置元素为行级块元素，让元素根据自身大小占据空间。然后给父级设置text-align来实现子级元素在父级元素水平居中1234567891011121314151617181920&lt;div class=&quot;father&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; text-align: center; &#125; .father div &#123; display: inline-block; width: 100px; height: 100px; background: orange; &#125; .father div:not(:last-child) &#123; margin-right: 10px; &#125;&lt;/style&gt; :not()除什么之外，当有多个元素时，如果给每个子级div都设置右边距时最后一个元素后边相应的也会有边距。然后总体来看就是第一个元素的左边和最后一个元素的右边剩余的大小是不一致的。所以最后一个元素不用设置右边间距。 (3)flex布局，最常用的居中方式1234567891011121314151617181920&lt;div class=&quot;father&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; display: flex; justify-content: center; &#125; .father div &#123; width: 100px; height: 100px; background: green; &#125; .father div:not(:last-child) &#123; margin-right: 10px; &#125;&lt;/style&gt; 主要就是通过给父级元素设置display: flex;属性为弹性弹性元素，然后设置主轴justify-content对齐方式为居中对齐。 垂直居中水平垂直居中已知宽高的元素(1)绝对定位与负边距实现1234567891011121314151617181920&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; position: relative; top: 200px; &#125; .son &#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; background: red; margin-top: -50px; margin-left: -50px; &#125;&lt;/style&gt; 父级相对定位，子级绝对定位，子级相对于父级来挪动位置。当给子级设置top: 50%;和left: 50%;时子级的左顶点刚好在父级中心，所以子级需要相对父级左移，上移。设置子级margin-top和margin-left为自身高度和宽度的负的一半。 给父级设置top: 200px;是因为父级默认从页面最顶端开始布局，子级相对父级垂直居中会使子级元素超出父级。 (2)绝对定位与margin(无需知道被居中元素的宽，高)123456789101112131415161718192021&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; position: relative; top: 200px; &#125; .son &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 100px; height: 100px; background: blue; &#125;&lt;/style&gt; 子元素相对父元素绝对定位，margin设置为auto时默认只能在水平方向上居中。只有给元素设置top, left, right, bottom时才能看到父级元素的宽和高，此时再设置margin: auto;元素就能根据父级进行居中]]></content>
      <categories>
        <category>页面布局</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐式类型转换]]></title>
    <url>%2F2018%2F09%2F24%2F%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[你可能见到过这样的情况：”5” - 3 == 2和”5” + 3 == “53”，可是这是为什么呢？ 上节提到过关于强制类型转换到的概念，通过调用方法来实现数据在不同类型间的转换。同样的，既然有强制类型转换，那么也会有隐式类型转换。 隐式类型转换转换为数字类型进行比较运算。以下几种情况会有数据的默认转换： isNaN()翻译过来意思就是：是NaN吗？此方法会先调用Number()的方法将数据转化为数字类型来进行比较。 数字类型包括四个值：具体的数字，NaN，Infinity，-Infinity 如果转换为数字时，返回的值刚好是NaN，则调用isNaN()时返回true。 具体步骤为：isNaN(demo) =&gt; Number(demo) =&gt; NaN =&gt; true / false 1234isNaN(23) //falseisNaN(&apos;a&apos;) //trueisNaN(NaN) //trueisNaN(null) //false 当调用Number()数据是怎么转换的，可以参考上一篇(强制类型转换)。Number(null)值为0 ++/- -, +/-++ / - - 分为前置++和后置++，区别在于变量的输出顺序不同。+/- 为一元正负运算符，并不是通常所说的数学中的加和减。即+4, -3 123+3 //3-5 //-5+&apos;a&apos; //NaN 12var str = &apos;a&apos;;console.log(str ++); //NaN 算数运算符‘+ , - , * , / , % (取余) ‘会将符号两边的值转换为数字进行运算 123456null + 1 //1&quot;abc&quot; + 1 //&quot;abc1&quot;&quot;2&quot; * &quot;a&quot; //NaN8 - &quot;2&quot; //65 / &quot;3&quot; //1.66666666666666675 % &quot;3&quot; //2 需要注意的是： + 号遇到字符串时，相当于字符串的拼接，他会把加号另外一边不是字符串的值转化为字符串，并和已知的字符串进行拼接。 如果没有字符串时，则将 + 两边的值正常转换为数字类型来进行计算。 1232 + &quot;&quot; //&quot;2&quot;2 + &quot; &quot; //&quot;2 &quot;2 + &quot;5&quot; //&quot;25&quot; 空串””和空格字符串” “的区别在于其布尔值，空串””为false，空格字符串” “为true 逻辑运算符‘ &amp;&amp;(与) ， ||(或) ， !(非) ‘输出运算结果。运算结果为真实的值(1) &amp;&amp; (2)：找到假为止。他会先取出(1)表达式的值，看是否为真。(1)为真,继续执行(2)，不管(2)结果为真还是为假都输出(2)表达式的运算结果。(1)为假，输出(1)表达式的运算结果。 (1) || (2)：找到真为止。他会先取出(1)表达式的值，看是否为真。(1)为真，输出(1)表达式的运算结果。(1)为假，继续执行(2)，不管(2)结果为真还是为假都输出(2)表达式的运算结果。 !(1)：取反。(1)运算结果为真时，取反则为假。(1)为假，取反为真。 1231 &amp;&amp; 2 //2&quot;a&quot; || NaN //&quot;a&quot;!4 //false 比较运算符‘ &gt; , &lt; , &gt;= , &lt;= , == , != ‘比较结果为布尔值 1234561 == &quot;1&quot; //true&quot;a&quot; &gt; &quot;b&quot; //false0 == &quot;&quot; //true0 == false //trueundefined == null //trueNaN == NaN //false 字符串和数字比较时，会将字符串转化为数字进行比较。字符串比较时，比较的为ASCII值。 根据undefined和null的特殊性质(undefined和null不等于0，不大于0，不小于0)，所以让他们两个相等。 NaN不等于任何值，包括他自身。 不发生类型转换===(绝对等于) , !==(绝对不等于)121 == &quot;1&quot; //true1 === &quot;1&quot; //false 小练习1211 + &quot;11&quot; //&quot;1111&quot;undefined == NaN //false 1234567var str = &quot;abc&quot;;str += 1; //&quot;abc1&quot;var test = typeof(str); //&quot;string&quot;if (test.length == 6) &#123; //new String(str).length = 6; =&gt; delete test.sign = &quot;typeof的返回值可能为string&quot; &#125;console.log(test.sign); //undefined 包装类。强行给原始值加上某个属性时可以加上，但是实际访问时并不存在。所以if的条件并不成立，即不能给test加上sign属性。 12345var str = false + 1; console.log(str); //1var demo = false == 1;console.log(demo); //false 有赋值和比较运算符时，先比较后赋值。即false != 1, 比较运算符，输出结果为布尔值。 1typeof typeof(undefined); //&quot;string&quot; 123if (typeof(a) &amp;&amp; -true + (+undefined) + &quot;&quot;) &#123; console.log(&quot;hello&quot;); //hello&#125; typeof(a)返回值为”undefined”，数据类型为字符串，为真。接着逻辑运算符后面的代码，-true + (+undefined) + “” =&gt; -1 + NaN + “” =&gt; NaN + “” =&gt; “NaN”，为字符串类型，为真，执行if里面的条件语句。 12345if (11 + &quot;11&quot; * 2 == 33) &#123; console.log(&quot;smile&quot;); //smile&#125;!!&quot; &quot; + !!&quot;&quot; - !!false || console.log(&apos;no&apos;); //1 + 0 - 0 =&gt; 1 123[3 &lt; 1 &lt; 2, 1 &gt; 2 &gt; 3]; //[true, false][3 &lt; 1 &lt; 2, 3 &lt; 1 &lt;= 0]; //[true, true] 当有多个比较运算符时，从左到右两个值一起进行比较，并将第一次比较的结果和第二次比较运算符右边的值作比较。 3 &lt; 1 &lt; 2比较时就是先让3和1比，3 &gt; 1，所以第一个比较的结果返回false(0)，然后再让0和后面的2比，0 &lt; 2, 所以比较结果为真，返回true。 也就是3 &lt; 1 &lt; 2 =&gt; 0(false) &lt; 2 =&gt; true]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制类型转换]]></title>
    <url>%2F2018%2F09%2F23%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在js里面声明变量时并没有直接定义该变量是什么类型，变量的类型由为他赋值时所定义的值所决定(var num = 123,定义了该变量为数字)。 但是有这么一种情况，当我们需要的变量是一个数字类型，但用户输入时给定的却是一个字符串。除了给用户提示输入正确的数据类型外，是否可以从前端的角度做一些关于数据类型的处理？ 这就出现了数据类型的转换。当一个变量从某种类型转化为另外一种类型时，则可以调用对应变量类型的方法。 强制类型转换针对js中的数据类型原始值(number，string，boolean，undefined，null)和引用值(array，object，function)，当不同的数据类型调用不同的方法时，看其相应的返回值。 Number()该方法会把任意类型的数据转换为数字类型。 数字类型包括四个值：具体的数字，NaN，Infinity，-Infinity1234567Number(123.0) //123Number(0.300) //0.3Number(030) //30Number(0/0) //NaNNumber(1/0) //InfinityNumber(-1/0) //-InfinityNumber(6/2) //3 当输入具体数据时，直接输出数据。但是会对数据做以下处理：(1)如果数字的最高位为0，删除最高位的0，返回有效的数据(2)如果小数点后面有0，删除小数点后面无效的0(3)如果输入的数据需要计算，则返回最后的计算结果 123Number(&apos;123&apos;) //123Number(&apos;abc&apos;) //NaNNumber(&apos;123abc&apos;) //NaN 当输入字符串时，会出现3种情况：(1)输入的字符串为纯数字，则返回具体数字(2)输入的字符串为纯字符，则直接返回NaN(3)输入的字符串同时包含数字和字符，返回NaN 12Number(true) //1Number(false) //0 当输入布尔值时，true =&gt; 1，false =&gt; 0 12Number(undefined) //NaNNumber(null) //0 需要注意的是，输入null时返回的是0 123Number(&#123;a:1,b:2,c:&#123;d:1&#125;&#125;) //NaNNumber([1,2,3]) //NaNNumber([1]) //1 输入引用类型的数据时，返回的值为NaN。 但有一种特殊的情况就是当要转换的变量为数组，切数组的长度为1时，该数据类型可以直接转换为相应的数据 parseInt()该方法趋向于将字符串转换为数字类型。12parseInt(112) //112parseInt(112.14) //112 输入数字时，该方法会有截取的功能，截取数字的整数部分。 即可以调用该方法将数字直接转化为整型数字(没有小数) 123parseInt(&apos;112&apos;) //112parseInt(&apos;112px&apos;) //112parseInt(&apos;abc&apos;) //NaN 当输入字符串时，会出现3种情况：(1)输入的字符串为纯数字，则返回具体数字(2)输入的字符串为纯字符，则直接返回NaN(3)输入的字符串同时包含数字和字符，该方法会有截取的效果。则从第一个字符串开始，到非数字位截止。返回截取的数字部分 1234567parseInt(true) //NaNparseInt(undefined) //NaNparseInt(null) //NaNparseInt(&#123;a:1&#125;) //NaNparseInt(&#123;1:1&#125;) //NaNparseInt([1]) //1parseInt([1,2]) //1 当变量类型为引用值时，直接返回NaN。但需要注意的是，当定义的数组为第一位为数字时，返回该数组的第一位。 该方法的关键在于，趋向于将字符串转换为数字。当定义的变量不是字符串时，通常返回NaN(数字直接返回截取后的值。数组第一位为数字时，直接返回数组第一位) 该方法还可以传第二个参数，parseInt(num, radix)表示num是radix进制的数据，以radix为基底将num转换为十进制的数字。1parseInt(&apos;123a&apos;, 16) //4666 该例子表示将16进制(包括0-9, a-f)的123a转换成十进制对应的数据 12parseInt(&apos;112&apos;, 2) //3parseInt(&apos;121&apos;, 2) //1 当要转换的数据超出了该进制所包含的值时，会从超出进制的数据位对该数据进行截取，再对截取后的数据调用该方法进行转换。 将’112’的二进制转换为十进制的数据时，因为二进制只能包括0和1，所以会对’112’进行截取，截取后的数据为’11’，再将’11’转化为十进制 parseFloat()将字符串转换为数字类型，parseInt()不同的是：(1)可以在parseInt()的基础上保留一个小数点，即可以将数据转化为浮点型(含有小数)并去除无效的0(2)没有第二个参数，即没有进制间的转换 12parseFloat(&apos;123.020&apos;) //123.02parseFloat(&apos;123.020.21&apos;) //123.02 以上三个方法都是将变量转换为数字。 Boolean()将变量转换为布尔值(0或1)12Boolean(123) //trueBoolean(&quot;&quot;) //false 转换成布尔值为false的有：NaN, 0, “”, false, undefined, null 其他值转换为布尔值均为true String()将变量转化为字符串 1234String(123) //&quot;123&quot;String(true) //&quot;true&quot;String(undefined) //&quot;undefined&quot;String(null) //&quot;null&quot; 将任意类型直接转换为字符串，即相当于num + “” toString()将变量转化为字符串，除undefined, null(没有原型) 12.toString() //error 这里趋向于变量调用该方法进行转换，数字直接调用时会报错。 如果传入的数据为数字类型时，应该采用如下方式处理：1var num = 3;num.toString() //&quot;3&quot; 12var num = 070; num.toString() //56var num=0110;num.toString() //&quot;72&quot; 当数字第一位为0时，会被默认为八进制，然后将其转换为十进制。即将八进制的070转换为十进制 再看以下例子：1233.toString() //error3..toString() //&quot;3&quot;3...toString() //error, Unexpected token . 3..toString()中，3..相当于3.0来调用toString()的方法进行转换。 换句话说就是，如果数字直接调用toString()方法时，只有数字类型为小数(浮点型)才不会报错。否则都应该以变量声明的形式来调用。 1233.1.toString() //&quot;3.1&quot;3.0.toString() //&quot;3&quot;3.900.toString() //&quot;3.9&quot; 该方法可以去除小数点后面无效的0 再看其他类型的数据调用该方法时：1234true.toString() //&quot;true&quot;undefined.toString() //err[1,2].toString() //&quot;1,2&quot;&#123;a: 1, b: 2&#125;.toString() //err 通过以上例子我们发现，当数组调用toString()方法时，会将数组直接转换为字符串。 但以上数组的组成均为数字，如果数组中含有其他类型的变量时，是否依然成立呢？123[1, 2, &apos;a&apos;, &apos;b&apos;, 8].toString() //&quot;1,2,a,b,8&quot;[1, [4, &apos;a&apos;], &#123;b : 1&#125;, &apos;c&apos;].toString() //&quot;1,4,a,[object Object],c&quot;[1, undefined, &apos;b&apos;, null].toString() //&quot;1,,b,&quot; 首先，null, undefined是不能调用toString()方法的，直接调用时报错。在数组中调用时，数组对应的位置为空。 对象调用toString()方法也直接报错，在数组中时，返回该数据的类型[object Object]。 该方法还可以传第二个参数，variable.toString(k)表示将十进制的variable转换为k进制的数据，即将十进制转换为k进制1var num = 123; num.toString(16) //&quot;7b&quot; 再看以下例子：将二进制10101010转换为16进制的数据 分析题目并结合以上知识点可以想到，先将二进制的数据转换为十进制，再将十进制转化为十六进制1234var num2 = 10101010;var num10 = parseInt(num2, 2);var num16 = num10.toString(16);console.log(num16); //&quot;aa&quot;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typeof返回值]]></title>
    <url>%2F2018%2F09%2F22%2Ftypeof%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[js基本数据类型js里面基本数据类型分为原始值和引用值两大类。 其中原始值包括数字number，字符串string，布尔值boolean，undefined，null五种。 引用值包括数组array，对象object，函数function三种。 typeof判断数据类型当传入一个变量时，可以用typeof来判断基本的数据类型。 根据传入的数据类型进行划分，typeof的返回值包括”number” ，”string” ，”boolean” ，”undefined” , “object” ， “function”六种 其调用形式如下：(1)typeof num(2)typeof(num) 其中，typeof后面跟的为需要判断数据类型的变量。传入的变量可以直接跟在typeof后面以空格分隔开，也可以直接写在括号里 看如下例子：123typeof 123; //&quot;number&quot;typeof NaN; //&quot;number&quot;typeof Infinity; //&quot;number&quot; 但凡是数学计算能产生的结果都是数字类型，数字类型的返回值为”number” 12345var str = &apos;123abc&apos;;typeof str; //&quot;string&quot; typeof +str; //&quot;number&quot;typeof !!str; //&quot;boolean&quot;typeof str + &apos;&apos;; //&quot;string&quot; 输入一个字符串，字符串可以通过运算符改变其类型，typeof会根据类型返回特定的值 1typeof a; //&quot;undefined&quot; 在js中，一个变量未经声明就使用，只有在一种情况下不会报错，那就是将变量放在typeof里面查看类型 综上总结，可以将基本数据类型和typeof的返回值做如下对应关系：typeof的返回值: “number” ，”string” ，”boolean” ，”undefined” , “function” ，”object”返回值为”number”包括：数字类型(number)返回值为”string”包括：字符串类型(string)返回值为”boolean”包括：布尔值(boolean)返回值为”undefined”包括：undefined(即值未定义)返回值为”function”包括：函数function比较特殊的是，返回值为”object”包括：null，数组array，对象object 所以当需要判断具体的”object”类型时，需要对null，array，object进行判断 注意点typeof的返回值均为字符串，即number类型的字符串，string类型的字符串，boolean类型的字符串，undefined类型的字符串，function类型的字符串，object类型的字符串 即typeof(typeof “number”) =&gt; “string” 特殊情况考虑以下情况，当基本数据类型的首字母大写时，相应的typeof是否也会发生改变呢？12345678typeof Number //&quot;string&quot;typeof String //&quot;string&quot;typeof Boolean //&quot;string&quot;typeof Undefined //&quot;undefined&quot;typeof Null //&quot;undefined&quot;typeof Array //&quot;string&quot;typeof Object //&quot;string&quot;typeof Function //&quot;string&quot; 总结起来就是返回值为”string”包括：Number / String / Boolean / Array / Object / Function返回值为”undefined”包括：Undefined / Null]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>typeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行内元素和块级元素]]></title>
    <url>%2F2018%2F09%2F21%2F%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[元素分类块级元素(block)常用元素：div / p / ul / li / ol / form / address / h(h1-h6) 特点：元素独自占据一整行，可以给元素设置宽和高 具体设置如下：12345678910111213&lt;div class=&quot;red&quot;&gt;&lt;/div&gt;&lt;div class=&quot;blue&quot;&gt;&lt;/div&gt;&lt;style&gt; div &#123; width: 100px; height: 100px; background: red; &#125; .blue &#123; background: blue; &#125;&lt;/style&gt; 在浏览器中展示如下：可以看到，第一个div的宽度只有100px, 但是他占据了浏览器的一整行。使得第二个div换行展示 行内元素(inline)常用元素：span / a / em / del / strong 特点：根据自身内容占据空间大小，不能给元素设置宽和高 具体设置如下：12&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 在浏览器中展示如下：可以看到，span根据自身的内容占据了相应的大小，后面的span紧挨着进行展示 行级元素虽然不可以设置宽高，但可以给他设置字体大小(font-size)，字体颜色(color)，字体样式(font-family)等和字体相关的属性 行级块元素(inline-block)也叫内联元素，常用元素：img / input 特点：根据自身内容占据大小，又可以给元素设置宽和高 具体设置如下：12345678910&lt;input type = &quot;text&quot;&gt;&lt;input type = &quot;text&quot;&gt;&lt;style&gt; input &#123; width: 200px; height: 30px; margin-right: 30px; &#125;&lt;/style&gt; 在浏览器中展示如下： 行级块元素input设置了宽和高，第一个input占据的宽度仅为设置的宽度，第二个input紧挨着第一个进行展示 行级块元素通常会被分类在行内元素里面 相互转换关系块级元素默认display: block 行内元素默认display: inline 行级块元素默认display: inline-block 当给块级元素设置display: inline或设置display: inline-block时，块级元素可以转换为行内元素或者行级块元素，并具有行级元素或行级块元素独有的特性。以此类推。 注意点margin和padding为复合属性，默认顺序为(上 右 下 左)。 块级元素的margin值包括(margin-top, margin-right, margin-bottom, margin-left)，padding值包括(padding-top, padding-right, padding-bottom, padding-left) 但行内元素只有margin-left, margin-right, padding-left, padding-right值 根据默认margin和padding分类只有默认margin值：body / p / form h(h1-h6) 只有默认padding值：input / img / textarea / button 有默认padding和margin：ol / ul 没有默认padding和margin：div / span body默认有8px的margin值 只有清除默认的padding和margin值我们设置的css样式才不会有偏差，样式才能布满整个页面 常用的处理方式：一般在css全局里面定义以下代码：1234* &#123; padding: 0; margin: 0;&#125; 也可以在总样式文件里面定义如下内容：1body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, textarea, p, blockquote, th, td, img &#123;padding: 0; margin: 0;&#125; 即选出css中可能用到的具有margin和padding的标签，将其初始化]]></content>
      <categories>
        <category>元素分类</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>行内元素</tag>
        <tag>块级元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组扁平化]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[你可能会看到这样一种情况，大概的描述就是一个数组里面包含了很多了数组，数组里面还可以包含数组。或者是一个数组里面包含了很多个对象。 我们通常需要的只是一维的数组，此时就需要将数组扁平化处理]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找法]]></title>
    <url>%2F2018%2F09%2F03%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分查找法二分查找法也称折半查找法，适用于在已知排列顺序的有序数组查找某个特定元素。 原理：(1)首先，从数组的中间位置开始查找。如果要查找的元素等于中间元素，返回中间元素索引。否则，进行第二步。 (2)如果要查找的元素大于中间元素，则在数组大于中间元素的那半区域进行查找； 如果要查找的元素小于中间元素，则在数组小于中间元素的那半区域进行查找。 然后重复第一步的操作。 (3)如果要查找的元素不存在，则返回-1。 具体实现12345678910111213141516171819function search (data, target) &#123; var start = 0, end = data.length - 1; while (start &lt;= end) &#123; var middle = Math.floor((start + end) / 2); //找到中间元素 if (target === data[middle]) &#123; return middle; &#125;else if (target &gt; data[middle]) &#123; start = middle + 1; &#125;else &#123; end = middle - 1; &#125; &#125; return -1; //要查找的元素不存在&#125;var arr = [1, 5, 2, 7, 13, 2, 3, 4, 34];var result = search(arr, 7); //方法调用console.log(result); //3,返回目标元素的索引]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序法]]></title>
    <url>%2F2018%2F09%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序法在看阮一峰老师的快速排序法时，总能看到网上各种各样的吐槽文章，都说阮老师的实现方法有问题。那么，具体问题到底在哪呢？ 本着学习的心态，查找了一些相关的文章和实现方法，发现大家都是不约而同的采用阮老师的实现方法。我在阮老师的基础上做了一点改进，如下。 原理(1)选基准：选择数组里面的任意一个元素作为基准数(我以中间元素为例)。 (2)划分数组： 小于基准数的元素放在’基准’左边； 大于基准数的元素放在’基准’右边； 等于基准数的元素和’基准’放在一起。 (3)递归：对’基准’左边和右边两个子集，不断重复第一步和第二步，直到所有子集只剩一个元素为止。 具体实现123456789101112131415161718192021222324252627function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; //递归出口，当数组长度小于等于1时返回 return arr; &#125; var temple = Math.floor(arr.length / 2); var flag = arr.splice(temple, 1)[0]; var left = [], middle = [flag], right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; flag) &#123; left.push(arr[i]); &#125;else if (arr[i] &gt; flag) &#123; right.push(arr[i]); &#125;else &#123; middle.push(arr[i]); &#125; &#125; return quickSort(left).concat(middle, quickSort(right));&#125;var arr = [2, 5, 23, 10, 7, 8, 12, 7, 6];var newArr = quickSort(arr);console.log(newArr); //[2, 5, 6, 7, 7, 8, 10, 12, 23] 待排序数组每次调用quickSort方法时，都会被分成左，中，右三个数组。对左边和右边的数组再用相同的方法进行排序，最后返回排序完成的数组。 相关方法：(1) Math.floor() 向下取整 temple = Math.floor(arr.length / 2); 当数组长度为偶数时，刚好取到中间左边的那位，var arr = [2, 5, 23, 10],temple == 5; 当数组长度为奇数时，刚好取到中间的那位，var arr = [2, 5, 4，23, 10],temple == 4; (2) Array.splice(start, length) 从第几位开始删除数组，删除几个长度，直接操作原数组，并返回原数组，数组中的每一项为删除的数据 (3) Array.concat(arr1, arr2, …) 多个数组arr1, arr2和数组Array进行拼接成一个数组，返回拼接完成后的数组 总结我和阮一峰老师快排的不同主要在于多了一个middle数组来接收和’基准’一样的元素。 用递归方法来实现时，需要考虑到每次进行操作时共同点在哪（即找规律，找公式）。 还要考虑到当满足一定条件时跳出（即出口），否则程序将会陷入死循环。]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序和选择排序]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[关于数组的操作，经常会涉及到时间复杂度，空间复杂度，稳定性和不稳定性几个概念。 时间复杂度：一个程序执行所需要的时间，主要针对的是for循环 空间复杂度：程序所需的存储空间，可以估算出内存的大概使用情况 稳定性：如果a = b，a在b的前面，排序后a任然在b的前面 不稳定性：如果a = b，a在b的前面，排序后a在b的后面 具体的归纳情况可以见下图： 数组的排序方法冒泡排序法原理：依次比较数组里面每相邻的两个元素。如果前面的数比后面的数大，则将两个数交换顺序。也就是找到数组的最大数放在最后一位。 重复相同的规律，每次找出剩下数组里面的最大数放在最后面，直到数组有序排列为止。 具体实现(原型链编程)：1234567891011121314151617Array.prototype.bubbleSort = function () &#123; var temple; for (var i = 0; i &lt; this.length - 1; i++) &#123; //this指向被调用的对象 for (var j = 0; j &lt; this.length - 1 - i; j++) &#123; if (this[j] &gt; this[j+1]) &#123; temple = this[j]; this[j] = this[j+1]; this[j+1] = temple; &#125; &#125; &#125; return this;&#125;var arr = [1, 5, 2, 7, 13, 2, 3, 4, 34];var arrSort = arr.bubbleSort(); //方法调用console.log(arrSort); //[1, 2, 2, 3, 4, 5, 7, 13, 34] 需要注意的是，每两个数进行比较大小时，知道第n - 1个数，则可以比较出第n - 1个数和第n个数的大小。所以第一个for循环终止条件为arr.length - 1。 第二个for循环时，当i = 0时，需要循环的次数为arr.length - 1,第一次循环结束的结果是选出最大的数放在数组最后，即排序后的数组为[1, 2, 5, 7, 2, 3, 4, 13, 34]。 当i = 1时，循环次数为arr.length - 1 - 1，即最后一个数已经确定大小，不需要比较。还有余下数组的最后一位也不需要比较。 当然啦，这样做是为了节省时间复杂度，当两圈for循环的终止条件改为arr.length也是可以的。 选择排序原理：选择排序是指选出数组里面的第一个数依次和后面的每个数作比较，如果后面的数比第一个数小，交换顺序（选出最小的数放在第一位）。 再选出第二个数依次和后面的每个数作比较，选出余下数组里面最小的放在第二位。 重复以上规律，知道数组有序为止。 具体实现：12345678910111213141516Array.prototype.selectSort = function () &#123; for (var i = 0; i &lt; this.length - 1; i++) &#123; //this指向被调用的对象 for (var j = i + 1; j &lt; this.length; j++) &#123; if (this[i] &gt; this[j]) &#123; temple = this[i]; this[i] = this[j]; this[j] = temple; &#125; &#125; &#125; return this;&#125;var arr = [1, 5, 2, 7, 13, 2, 3, 4, 34];var arrSelect = arr.selectSort(); //方法调用console.log(arrSelect); //[1, 2, 2, 3, 4, 5, 7, 13, 34] 冒泡排序和选择排序的区别比较冒泡排序和选择排序，发现他们其实实现原理都是一样的。 区别在于，冒泡排序是每两个相邻元素作比较，每次排序的结果是选出当前数组中的最大元素放在数组最后。选择排序是第一个元素依次和后面的每个元素比，选出最小的元素放在数组第一位。依次重复类推。 冒泡排序是先确定最大元素放在最后，选择排序先确定最小元素放在第一位，所以他们最终的结果都是数组里面的数升序排列。]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[数组去重数组去重是后续经常会用到以及面试中经常用到的知识点，最近在复习中整理了以下几种方法仅供大家参考。 原生方法原理：建立一个新数组，取出原数组的每一项和新数组的每一项作对比，将原数组中存在而新数组中不存在的元素添加到新数组中，最后返回新数组 具体实现（原型链上编程）：12345678910111213141516171819Array.prototype.unique = function () &#123; var newArr = [this[0]]; //谁调用的unique方法，this指向谁（arr) for (var i = 0; i &lt; this.length; i++) &#123; var flag = true; for (var j = 0; j &lt; newArr.length; j++) &#123; if (this[i] === newArr[j]) &#123; flag = false; &#125; &#125; if (flag) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 需要注意的是：1.第二个for循环遍历的次数为newArr.length，如果newArr为空，则不会进入for循环，将不会执行后面的语句。 2.第二个for循环里不能只是简单的根据条件判断arr[i] !== newArr[j]便试图直接调用newArr.push(arr[i])的方法来进行添加。 试想一下，当数组arr遍历到第3位(即1)时，此时newArr == [1, 2]，newArr.length == 2；进入第二个for循环中，循环次数为2。 第一次循环时arr[i] === newArr[j] (即1 == 1)，不会进入if循环；第二次arr[i] !== newArr[j] (即1 != 2)，进入if语句，执行push语句，所以会再次向newArr中添加1，返回newArr = [1, 2, 1],以此类推。 即以下写法是错误的：1234567for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; newArr.lenght; j++) &#123; if (arr[i] !== newArr[j]) &#123; newArr.push(arr[i]); &#125; &#125;&#125; 利用对象的属性名无重复原理：对象的属性名是没有重复的，取出数组的每一位，看对象里面是否存在（即取出对象的属性名，看对应的属性值是否存在。如果不存在，则证明对象中没有这个属性，该元素在数组中是第一次出现，并将该元素添加到新数组中）。此时需要给不存在的属性赋值做标记 具体实现：123456789101112131415Array.prototype.unique = function () &#123; var obj = &#123;&#125;; var newArr = []; for (var i = 0; i &lt; this.length; i++) &#123; if(!obj[this[i]]) &#123; obj[this[i]] = 1; newArr.push(this[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 调用splice()删除重复元素原理：取出数组中的每一个元素依次和后面的每一个元素对比，如果后面的元素有相同的则为重复元素，删除该元素 相关方法：splice(start, length) 从第几位开始删除数组，删除几个长度，直接操作原数组，并返回原数组，数组中的每一项为删除的数据 slice(start, end) 截取数组的start位到end位（但不包括end位）的值，返回一个新数组。原数组不改变 具体实现：1234567891011121314Array.prototype.unique = function () &#123; for (var i = 0; i &lt; this.length; i++) &#123; //谁调用的unique方法，this指向谁（arr) for (var j = i + 1; j &lt; this.length; j++) &#123; if (this[i] === this[j]) &#123; this.splice(j, 1); &#125; &#125; &#125; return this;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] indexOf()找出符合条件的第一个原理：根据indexOf()来判断该元素是否是第一次出现，即看当前元素的索引值是否是满足条件的第一个索引值。 相关方法：Array.indexOf(item): 返回item元素在当前数组中第一次出现的索引值，不存在则返回-1。 具体实现：123456789101112Array.prototype.unique = function () &#123; for (var i = 0; i&lt; this.length; i++) &#123; if(this.indexOf(this[i]) !== i) &#123; this.splice(i, 1); &#125; &#125; return this;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] filter()按一定规则遍历数组原理：用filter来遍历生成满足条件的新数组，判断的条件需要借助indexOf()来判断当前元素的索引是否等于当前的索引 相关方法：filter(item, index, array) 有三个参数，第一个为数组的每一项(相当于arr[i])，第二个为当前元素的索引(i)，第三个为原来的数组(即调用filter的那个数组)。 该方法会返回一个满足条件的新数组。 具体实现：12345678910Array.prototype.unique = function () &#123; var newArr = this.filter(function (item, index, array) &#123; return array.indexOf(item) === index; &#125;) return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 看到这里相信你应该已经明白，filter()方法就相当于for循环的封装，本质上还是取出数组中的当前项和当前索引，看该元素的索引值是不是第一次出现 sort()先排序，再去重原理：先将数组进行排序，相同的数据会排列在一起。 所以进行数组去重时只需要将当前数据与前一个数据作对比。如果当前数据不等于前一个数据，则说明该数据是第一次出现。 可以利用一个新数组，每次将数据添加到新数组时，通过判断当前的数据与新数组的最后一位是否相等。如果不相等，则将该数据push到新数组。 相关方法：Array.sort() 默认将数组按照ASCII进行排序。 当里面传入一个回调函数时，即Array.sort(function (a, b) {return 1;})为升序排列；当return -1时为降序排列。 具体实现：1234567891011121314Array.prototype.unique = function () &#123; this.sort(); var newArr = []; for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] !== newArr[newArr.length - 1]) &#123; newArr.push(this[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 13, 2, 3, 34, 4] 从结果可以看到，返回的数组根据ASCII升序排列。 Set()数据结构原理：调用ES6中的Set数据结构可以用于数组去重 具体实现：123var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var setArr = new Set(arr);console.log(setArr); 结果：]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历]]></title>
    <url>%2F2018%2F08%2F15%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[参考文献：https://www.cnblogs.com/attitudeY/p/6790219.html和https://blog.csdn.net/zhouziyu2011/article/details/62236006 树树状图是一种数据结构，把他叫做树是因为他像一棵倒挂的树，根朝上，叶朝下。大概结构如下：图片来源：点击查看你所看到的每个元素叫做一个节点，一棵树可以有多个节点。 特殊的是，二叉树的节点不超过两个。最上面的没有父节点的（23）称为根节点，以根节点为分界点，可以把二叉树树分为左子树和右子树，如上图。二叉树常被用于实现二叉查找树和二叉堆。 二叉树的遍历深度优先遍历对于一棵二叉树，深度优先遍历是沿着树的深度遍历树的节点层数，尽可能深的搜索树的分支，其中，每个节点只能遍历一次。 深度优先遍历分为先序遍历，中序遍历，后序遍历。先序遍历：对任意子树，先访问根，然后遍历其左子树，最后遍历右子树。中序遍历：对任意子树，先遍历其左子树，然后访问根，最后遍历右子树。后序遍历：对任意子树，先遍历其左子树，然后遍历右子树，最后访问根。 广度优先遍历广度优先遍历又叫宽度优先搜索或横向优先搜索，是从根节点开始沿着树的宽度一层层的往下遍历，在每一层中，从左往右（或从右往左）访问每一个节点，访问完一层就进入下一层，直到找到最后一层。 请看下面例子：先序遍历：35 20 15 16 29 28 30 40 50 45 55中序遍历：15 16 20 28 29 30 35 40 45 50 55后序遍历：16 15 28 30 29 20 45 55 50 40 35广度优先遍历：35 20 40 15 29 50 16 28 30 45 55 深度优先和广度优先的区别深度优先：二叉树的深度优先遍历采用的是栈。深度优先遍历二叉树是先访问根节点，然后访问左子树，接着访问右子树。根据栈先进后出的原则，我们可以先将右子树压栈，然后将左子树压栈，这样左子树就位于栈顶，可以永远保证左子树先于右子树被访问到。 深度优先搜索不全部保留节点，拓展完的节点从数据库中弹出删去。这样，一般在数据库中存储的节点就是深度值，因此他占用空间少。适用于搜索树节点较多时。 广度优先：广度优先遍历采用的是队列。一般需存储产生的所有节点，占用的存储空间比深度优先搜索大的多。因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先算法没有出栈入栈的操作，运行速度比深度优先搜索快。 算法实现深度优先遍历递归实现123456789101112function dfs (node) &#123; var nodes = []; if (node !== null) &#123; nodes.push(node); var children = node.children; var len = children.length; for (var i = 0; i &lt; len; i++) &#123; dfs(children[i]); &#125; &#125; return nodes;&#125; 深度优先遍历非递归实现1234567891011121314151617function dfs (node) &#123; var nodes = []; if (node !== null) &#123; var stack = []; stack.push(node); while (stack.length !== 0) &#123; var item = stack.pop(); nodes.push(item); var children = item.children; var len = children.length; for (var i = len - 1; i &gt;= 0; i--) &#123; stack.push(children[i]); &#125; &#125; &#125; return nodes;&#125; 广度优先遍历递归实现1234567891011function bfs(node) &#123; var nodes = []; var i = 0; if (!(node == null)) &#123; nodes.push(node); bfs(node.nextElementSibling); node = nodes[i++]; bfs(node.firstElementChild); &#125; return nodes;&#125; 广度优先遍历非递归实现123456789101112131415function bfs(selectNode) &#123; var nodes = []; if (selectNode != null) &#123; var queue = []; queue.unshift(selectNode); while (queue.length != 0) &#123; var item = queue.shift(); nodes.push(item); var children = item.children; for (var i = 0; i &lt; children.length; i++) queue.push(children[i]); &#125; &#125; return nodes;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构，二叉树，深度优先，广度优先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[z-index]]></title>
    <url>%2F2018%2F08%2F14%2Fz-index%2F</url>
    <content type="text"><![CDATA[我曾经遇到过这样一个面试题，a和b为兄弟结构标签，c为a的子标签，当a标签的z-index为1，b为2，c为3时，页面该如何布局？1234567891011121314151617181920212223242526272829303132&lt;div class=&apos;a&apos;&gt;a &lt;div class=&apos;c&apos;&gt;c&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;b&apos;&gt;b&lt;/div&gt;&lt;style&gt; .a, .b &#123; width: 100px; height: 100px; &#125; .a &#123; position: absolute; z-index: 1; background: green; &#125; .b &#123; position: absolute; top: 60px; left: 60px; z-index: 2; background: blue; &#125; .c &#123; position: absolute; top: 20px; left: 20px; z-index: 3; width: 60px; height: 60px; background: orange; &#125;&lt;/style&gt; 你想到该如何布局了吗？ 跟浮动不一样的是，z-index是将元素抽离到更高层面进行定位，并不会影响到他原来的布局(在具有z-index属性后面的元素仍然是从z-index元素占据的开始位置进行布局，并保持着原来的特性和方式进行布局)。 z-index默认值为0，当多个元素具有z-index属性时，数字越大的显示时越在上面。 但要考虑到的一个情况是：如果父元素和子元素同时具有z-index属性时，要优先考虑父元素的z-index。即使子元素的z-index比父元素大，实际显示时也是以父元素的为准。父元素包裹着子元素，将子元素的z-index降为和父元素保持一致。 W3C 对 z-index 属性的描述中提到在 z-index 属性仅在节点的 position 属性为 relative, absolute 或者 fixed 时生效。 浏览器实际展示效果如下：c为a的子元素，但父级a具有z-index属性，以父元素为准，所以a和c的z-index都为1，b的z-index为2，所以b在最上面 想象一下，在三维坐标轴中，z轴代表物体的高度，当给物体加上z-index属性时，物体就具有了空间感，就能根据z-index对物体进行定位。 情形1：上面提到的是，z-index后面的元素会依照元素的性质从z-index元素占据的开始位置进行布局显示，于是我在具有z-index属性的元素后面添加了一些元素，来查看页面的布局到底是怎样的？ 修改后的代码如下：123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=&apos;a&apos;&gt;a &lt;div class=&apos;c&apos;&gt;c&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;b&apos;&gt;b&lt;/div&gt;&lt;span&gt;sssssssssggggggssssssrrrrrrrrr&lt;/span&gt;&lt;div class=&apos;content&apos;&gt;&lt;/div&gt;&lt;style&gt; .a, .b &#123; width: 100px; height: 100px; &#125; .a &#123; position: absolute; z-index: 1; background: green; &#125; .b &#123; position: absolute; top: 60px; left: 60px; z-index: 2; background: blue; &#125; .c &#123; position: absolute; top: 20px; left: 20px; z-index: 3; width: 60px; height: 60px; background: orange; &#125; .content &#123; width: 170px; height: 170px; background: #555; &#125;&lt;/style&gt; 浏览器中显示如下： 情形2：当父元素和子元素同时具有z-index属性时，会优先考虑父元素的z-index并以父元素为准。但当父元素没有z-index属性时，页面是否会根据z-index的数值大则在最上面排列来进行显示呢？ 修改最开始的代码，去掉父级a的z-index属性，此时具有z-index的只有子级c和元素b, c的z-index为3，b为2，此时页面会怎么显示呢？ 浏览器中显示情况： 情形3：对于同样的元素，当页面中直接没有z-index属性时，又该如何显示呢？ 修改代码，去掉所有的z-index属性，查看页面显示。 可以看到的是，此时页面显示和一开始元素都具有z-index属性时一致。这只是因为每个元素都具有position属性，具有position属性的元素会根据给元素设置的位置进行定位显示。 position: absolute;绝对定位。b此时会根据浏览器进行定位显示，再因为b元素排列在a元素后面，所以b元素会排列在最上层，于是就有了如图所示的显示。 对于同样的标签，当给他设置的是浮动属性而不是z-index时，将会发生什么呢？ 同样的，改变z-index为float，代码如下：12345678910111213141516171819202122232425&lt;div class=&apos;a&apos;&gt;a &lt;div class=&apos;c&apos;&gt;c&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;b&apos;&gt;b&lt;/div&gt;&lt;style&gt; .a, .b &#123; width: 100px; height: 100px; &#125; .a &#123; float: left; background: green; &#125; .b &#123; float: left; background: blue; &#125; .c &#123; float: left; width: 60px; height: 60px; background: orange; &#125;&lt;/style&gt; 浏览器中展示如下：具有浮动属性的元素将会脱离正常的文档流，被抽离到更高层面进行定位，所以a和b并排在一起，a里面包裹着他的子元素c。]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>浮动</tag>
        <tag>z-index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于元素的bfc]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%85%B3%E4%BA%8Ebfc%E5%8F%8A%E7%94%A8%E9%80%94%2F</url>
    <content type="text"><![CDATA[bfc–块级格式化上下文具有bfc特性的元素可以看做是隔离了的独立容器。容器里面的元素无论怎样变化，都不会在布局上影响到外面的元素，并具有普通元素没有的特性。 能够触发bfc特性的以下任意一个条件均能触发元素的bfc属性：(1)float: left / right(除none);(2)overflow: hidden / auto / scroll(除visible);(3)position: absolute / fixed;(4)display: inline-block / flex / inline-flex / table-cell /table-caption;(5)根标签body; bfc的用途I.清除浮动当给子级元素设置浮动属性时，需要给父级清除浮动。浏览器呈现的情况如下：代码如下：1234567891011121314151617181920&lt;div class=&apos;wrapper&apos;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; background: green; border: 2px solid #000; margin-top: 200px; &#125; .wrapper div &#123; float: left; margin: 30px; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 可以看到，父级包不住子级的div元素，需要给父级清除浮动触发父级的bfc，使其回到正常的文档流。 清除浮动的方法：123456789101112131415161718192021&lt;div class=&apos;wrapper&apos;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; display: inline-block; background: green; border: 2px solid #000; margin-top: 200px; &#125; .wrapper div &#123; float: left; margin: 30px; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 清除浮动后的样式:这里是通过给父级添加属性’display: inline-block’来实现，你也可以通过其他方法试一试。 II.解决margin塌陷请看下面情况：此时明明给父级和子级都设置了margin-top，但是浏览器所展现出来的只有父级的margin-top。 代码如下：123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 150px; height: 150px; background: orange; &#125;&lt;/style&gt; 这里涉及到盒子模型的概念。盒子模型的组成包括margin + border + padding + content。其中，在此提到的margin为复合属性，包括margin-top, margin-right, margin-bottom, margin-left。浏览器后台的盒子模型如下： margin塌陷指的是margin-top，针对的是具有父子结构嵌套的元素。 解决margin塌陷的方法1如果想要父级子级的margin-top都能正常的显示，此时只需要触发父级元素的bfc属性。12345678910111213141516171819&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; overflow: hidden; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 150px; height: 150px; background: orange; &#125;&lt;/style&gt; 修改后的展示如下： 上面是通过给父级添加overflow: hidden的属性来实现的，用overflow: hidden的缺点就是：如果子级元素大于父级元素时，子级多出父级元素的部分会被隐藏。 当子级溢出部分没有被隐藏时，实际展示效果如下： 此时和上面不同的只是使子级元素的宽度大于父级，多出的部分会超出父级正常显示。123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 给父级设置overflow：hidden属性后，浏览器显示如下：相应代码如下：12345678910111213141516171819&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; overflow: hidden; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 此时虽然能解决margin塌陷带来的坏处，但是却使子级多出父级的部分溢出隐藏，如果想要使子级多出的部分正常显示，就可以采取其他的方法来触发元素的bfc属性。 解决margin塌陷的方法2通过计算解决：当子级元素的margin-top大于父级时，实际展示效果将以子级的margin-top为准，子级会带动父级一起向下运动。123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 300px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 以上代码通过计算来解决margin塌陷，实际上在浏览器中最终所展示的margin-top为300px,而且不会影响到子级元素的大小。]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>浮动</tag>
        <tag>bfc</tag>
        <tag>margin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello MyBlog]]></title>
    <url>%2F2018%2F07%2F08%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[这是我搭建好博客后的第一篇文章，一切都会有个好的开始。 我是一个前端的小菜鸟，可能很多东西理解的也不太对，欢迎大家留言指正。 搭建博客博客基础这里主要借助的是 GitHub + Hexo 来进行搭建博客。可能你也像我一样是技术小白，可能你也正为如何搭建博客而烦恼，如果你想新建属于自己的博客，点击 这里 查看。 博客主题样式配置如果你想更换博客主题,配置自己喜欢的样式,点击 这里 查看。 上传本地博客相信看到这里的你已经按照以上的步骤配置好了属于自己的博客,此时博客只是在本地运行的,想要让本地博客能在浏览器里访问，快借助GitHub来进行配置吧！主要方法(在cmd工具栏中进入搭建博客的本地文件夹，输入如下命令)：1$ hexo g 1$ hexo d 具体可以参照 这里 来进行配置！ 新建文章新建页面配置好所有的环境之后，就可以在本地编辑器里写自己的博客内容了。首先，当然是要新建博客写作页面了。在hexo里面有三种新建的方式。在cmd里执行以下命令：1$ hexo new [layout] &lt;title&gt; 其中，layout为新建的位置，包含以下三个值：布局—————-路径post—————source/_posts (一般新建单个博客页面时使用)page—————source (用来配置和引入资源,包括图片,以及在搭建博客时的标签,分类页)draft—————source/_drafts (新建草稿)举个栗子:1$ hexo new post hello,hexo 1$ hexo new page tags 现在，你可以找到source文件夹查看具体区别。 配置参数每新建好一个文件，你可以看到最上面有用--- ---来隔开一个部分，这是用来进行参数匹配的。 在本篇博客里，我的配置是这样的：1234567---title: Hello MyBlogdate: 2018-07-08 09:58:00tags: [hexo,blog,essay]categories: 搭建博客comments: true--- 其中，tags和categories参数你需要先建立页面1$ hexo new page tags 1$ hexo new page categories 并在source文件夹下找到对应的tags页面，配置以下参数：12345---title: tagsdate: 2018-07-07 13:23:03type: &apos;tags&apos;--- 同理，在categories页面中配置：12345---title: categoriesdate: 2018-07-08 21:21:28type: &apos;categories&apos;--- 到这里，页面基本参数就配置好了，接下来主要就是要发布的博客内容。 文章标题一级标题：&lt;h1&gt;&lt;/h1&gt; –表示方法：# 名称二级标题：&lt;h2&gt;&lt;/h2&gt; –表示方法：## 名称三级标题：&lt;h3&gt;&lt;/h3&gt; –表示方法：### 名称一般我们标题都是用来语义化表示题目内容的，不宜嵌套太深，主要常用的就是前三级标题 网址链接表示方式：1[要显示的内容](与该内容相关的网址) 1[这里](https://www.jianshu.com/p/9d1b865217a5) 其他内容就正常书写就好啦！ 上传博客内容写到这里本篇博客内容页该结束啦！此时想要把本地写好的博客内容上传到浏览器里查看，只要执行以下代码就可以啦！开心~~~12$ hexo g$ hexo d 具体内容可以点击 这里 查看hexo官方文档]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
