<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数组中出现次数最多的元素]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[数组中出现次数最多的元素给定一个数组，找出数组中出现次数最多的元素。 举例如下：1var arr = [1, 3, 5, 2, 3, 9, 8]; 数组arr中出现最多的次数为3，出现次数为2，所以程序最后运行结果应该输出元素3。 (1)思路：分析题目可知，目的为找出数组中出现次数最多的元素。所以我们需要一个变量来记录数组中的每个元素，以及元素对应出现的次数。 由此联想到对象是由键值对的形式组成的，对象的属性名是唯一的。如果将数组中的元素作为属性名，那么元素出现的次数就是对应的属性值。元素出现多次时，则让相应的属性值+1。 最后再遍历对象，找出对象中属性值最大的元素(即出现次数最多)，返回其对应的属性名。 (2)知识点：for in循环通常用来遍历对象。用法为：for (var prop in obj)，其中，prop为对象的属性名，obj为要遍历的对象，obj[prop]即为取出对象的属性值。 for in通常和hasOwnProperty()配合使用，意为先看prop属性是否是对象本身的(该属性不在原型上)，来节约遍历成本。 (3)具体实现过程(原型链编程)：12345678910111213141516171819202122232425Object.prototype.maxTime = function () &#123; var obj = &#123;&#125;, count = 0, //记录出现次数 maxTimeNum; //记录次数最多的元素 for (var i = 0; i &lt; this.length; i++) &#123; if(!obj[this[i]]) &#123; //对象的属性值不存在，元素没有出现过 obj[this[i]] = 1; &#125;else &#123; obj[this[i]]++; //元素已经出现过，统计出现次数 &#125; &#125; for (var prop in obj) &#123; if(obj.hasOwnProperty(prop)) &#123; if(obj[prop] &gt; count) &#123; count = obj[prop]; maxTimeNum = prop; &#125; &#125; &#125; return &apos;最多次数元素：&apos; + maxTimeNum + &apos; 次数： &apos; + count;&#125;var result = arr.maxTime(); //方法调用console.log(result); 在这里，arr[i]取出数组中的每一项，obj[arr[i]]为取出对象的属性值。当取出数组中的第一个元素时，对象中没有该属性，把该元素添加到对象中，赋属性值为1。如果对象的属性值存在，则让该值+1。 最后对象遍历时会发现，如果只是简单的对属性值进行排序，可以取出最大的属性值，但是此时却无法找到对应的属性名。所以需要借助一个变量来记录属性名。 (4)输出结果： 字符串中出现次数最多的元素字符串循环字符串也是可以通过for循环遍历长度的。同样，str[i]也可以取出字符串中的每一位。所以遍历字符串中出现次数最多的元素时，直接改变上述方法传入的实参就可以使用。 要遍历的字符串如下：1var str = &apos;abbscackbpl&apos;; 调用上述的方法，传入参数：12var result = str.maxTime();console.log(result); 输出结果： 字符串拆分相关知识点：在数组的操作中，有一系列关于字符串和数组转换的方法，主要有以下两个：(1)str.split()根据传入的字符将字符串拆分成数组。 举例如下：除了上面提到的一些符号，还可以传入像逗号等特殊字符。其中，最常用的就是str.split(“”)直接将每一个字符串都拆开。 (2)str.join()与上述方法相反，这个是以什么形式将数组中的元素拼接成字符串，可以传入任意字符 基于以上，在查找字符串中出现次数最多的元素时，还有另外一种方法就是：先将字符串拆分成数组，再调用上面封装好的maxTime()方法来进行处理。 具体实现如下：1234567891011121314151617181920212223242526var newArr = str.split(&apos;&apos;);Object.prototype.maxTime = function () &#123; var obj = &#123;&#125;, count = 0, //记录出现次数 maxTimeNum; //记录次数最多的元素 for (var i = 0; i &lt; this.length; i++) &#123; if(!obj[this[i]]) &#123; //对象的属性值不存在，元素没有出现过 obj[this[i]] = 1; &#125;else &#123; obj[this[i]]++; //元素已经出现过，统计出现次数 &#125; &#125; for (var prop in obj) &#123; if(obj.hasOwnProperty(prop)) &#123; if(obj[prop] &gt; count) &#123; count = obj[prop]; maxTimeNum = prop; &#125; &#125; &#125; return &apos;最多次数元素：&apos; + maxTimeNum + &apos; 次数： &apos; + count;&#125;var result = newArr.maxTime(); //方法调用console.log(result);]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据某个属性将对象排序]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%A0%B9%E6%8D%AE%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%B0%86%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在实际的应用场景中我们可能会遇到这样的现象： 从后台请求得到一个数组，数组中的每一项都是对象，需要你根据对象的某个属性名将对象进行排序。例如根据首字母对省份地区的排序，根据学号对学生进行排序等。 大概举例如下：12345var arr = [ &#123;name: &apos;lzl&apos;, age: 22, id: 1552440205&#125;, &#123;name: &apos;amd&apos;, age: 15, id: 1345150504&#125;, &#123;name: &apos;fsm&apos;, age: 18, id: 1542559322&#125;,] 你会如何处理呢？ 在正式开始前，可能还需要补充以下知识点： arr.sort()对数组中的元素进行排序，默认为按照ASCII进行排序。 (1)将数组中的元素升序排列(从小到大)123arr.sort(function (a, b) &#123; return a - b;&#125;) (2)降序排列123arr.sort(function (a, b) &#123; return b - a;&#125;) 具体的可以查看上一篇中关于数组sort方法的具体介绍。 根据age属性排序基于以上，如果想要按照age属性对数组中的元素进行排序时，具体代码如下：12345arr.sort(function (a, b) &#123; return a.age - b.age;&#125;)console.log(arr); 输出结果如下： 根据用户传入的属性排序如果想要根据用户传入的某个属性直接进行排序，具体实现如下：1234567function propSort(prop) &#123; return function (obj1, obj2) &#123; return obj1[prop] - obj2[prop]; &#125;&#125;var newArr = arr.sort(propSort(&apos;id&apos;)); //调用方法console.log(newArr); 输出结果如下：调用上面方法时，取到的属性值都是数字，此时结果是正确的。那如果属性值是字符串时，结果会如何呢？ 分析方法可以知道，obj1[prop]取到的是字符串，此时’-‘号两边都是字符串，有隐式类型转换，相当于NaN - NaN, 返回的值还是NaN。无法判断等号两边的数值大小。 于是该方法可以做以下修改：1234567891011121314function sortBy (prop) &#123; return function (obj1, obj2) &#123; var str1 = obj1[prop]; var str2 = obj2[prop]; if(str1 &gt; str2) &#123; return 1; &#125;else &#123; return -1; &#125; &#125;&#125;var newArr = arr.sort(sortBy(&apos;name&apos;)); //调用方法console.log(newArr); 输出结果如下：以上方法同样适用于当属性值是数值时将数组进行排序。 当function返回值为负数时，两个相比较的数，前面的数在前(两个数不交换顺序);当function返回值为正数时，两个相比较的数，后面的数在前(两个数要交换顺序)。 封装方法根据传入的参数来进行判断是升序排列还是降序排列，封装方法如下：12345678910111213141516171819function sortBy (prop, flag) &#123; if (flag) &#123; flag = -1; &#125;else &#123; flag = 1; &#125; return function (obj1, obj2) &#123; var str1 = obj1[prop]; var str2 = obj2[prop]; if(str1 &gt; str2) &#123; return 1 * flag; &#125;else &#123; return -1 * flag; &#125; &#125;&#125;var newArr = arr.sort(sortBy(&apos;name&apos;, true)); //调用方法console.log(newArr); 输出结果如下：该方法默认为升序排列，当不传入数值或者传入的值为假时，为升序排列；否则为降序排列。 忽略字符大小写排序当字符串中同时含有大小写，且需要忽略字母大小写进行排序时，可以调用toLowerCase()方法将字母全部转化为小写 修改代码如下:1234567891011121314function sortBy (prop) &#123; return function (obj1, obj2) &#123; var str1 = obj1[prop].toLowerCase(); var str2 = obj2[prop].toLowerCase(); if(str1 &gt; str2) &#123; return 1; &#125;else &#123; return -1; &#125; &#125;&#125;var newArr = arr.sort(sortBy(&apos;name&apos;)); //调用方法console.log(newArr); 输出结果如下： 根据多个属性排序假设某个属性相等的情况下，我们是否能根据另外一个属性来对数组进行排序呢？ 答案当然是肯定的，模拟数据如下：12345678var arr = [ &#123;name: &apos;lzl&apos;, age: 22, id: 1552440205&#125;, &#123;name: &apos;amd&apos;, age: 15, id: 1345150504&#125;, &#123;name: &apos;fsm&apos;, age: 18, id: 1542559322&#125;, &#123;name: &apos;pmd&apos;, age: 18, id: 1234567895&#125;, &#123;name: &apos;abb&apos;, age: 22, id: 1512559320&#125;, &#123;name: &apos;slg&apos;, age: 22, id: 1552440220&#125;,] 具体实现方法：123456789101112function sortBy(prop1, prop2) &#123; return function (a, b) &#123; if(a[prop1] === b[prop1]) &#123; return a[prop2] - b[prop2]; &#125;else &#123; return a[prop1] - b[prop1]; &#125; &#125;&#125;var newArr = arr.sort(sortBy(&apos;age&apos;, &apos;id&apos;));console.log(newArr); 输出结果如图：]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的sort方法]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%95%B0%E7%BB%84%E7%9A%84sort%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组的排序是面试以及实际应用中都会经常用到的知识点。除了被我们熟知的冒泡排序，快速排序等排序算法之外，js中也封装了相应的API以供调用。 arr.sort()对数组中的元素进行排序，直接操作原数组，默认为升序排列。 下面会对sort()的具体用法，在不同场景下的区别，具体的实现原理进行介绍。以及如何根据已知的方法对数组进行无序排列。 当数组中的元素为字符时：123var arr = [&apos;b&apos;, &apos;e&apos;, &apos;d&apos;, &apos;a&apos;];arr.sort();console.log(arr); //[&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;] 当数组中的元素为数字时：123var arr = [5, 8, 2, 6, 1];arr.sort();console.log(arr); //[1, 2, 5, 6, 8] 当直接调用arr.sort()方法时，默认为按照ASCII码对数组中的元素进行排列 所以下面的情况可能会与我们想要得到的结果有差异：123var arr = [10, 5, 8, 2, 61, 1];arr.sort();console.log(arr); //[1, 10, 2, 5, 61, 8] 此时比较时，会取出数组中每个元素的第一位依次比较。第一位不同时，按ASCII排列。第一位相同，再比较第二位。 所以从以上例子我们可以得到如下结论： 直接调用arr.sort()方法进行比较时，比较的是ASCII值，与数字位数无关 那么如果我们想不论数字位数，直接根据数字大小进行排序；或者是对数组进行降序排列应该怎么处理呢？ arr.sort()中可以传入一个回调函数用来对数组中的元素进行处理。原理如下： 当function返回值为负数时，两个相比较的数，前面的数在前(两个数不交换顺序);当function返回值为正数时，两个相比较的数，后面的数在前(两个数要交换顺序)。 按照上面的原理，我们进一步探索sort方法：12345678910var arr = [10, 5, 8, 2, 61, 1];arr.sort(function (a, b) &#123; if(a &gt; b) &#123; return 1; &#125;else &#123; return -1; &#125;&#125;)console.log(arr); // [1, 2, 5, 8, 10, 61] 当a &gt; b时，返回正数，两个数交换顺序，将小的数(b)放在前面。 你可能会奇怪上面并没有提到当两个数相等时该如何处理？ 返回去看上面的代码，当a == b时，if条件不成立，进入else，返回负数，两个数不交换顺序。 当a &gt; b时，a - b &gt; 0;所以上面的代码还可以进行以下修改：12345678910var arr = [10, 5, 8, 2, 61, 1];arr.sort(function (a, b) &#123; if (a - b &gt; 0) &#123; return a - b; //此时a - b为正数 &#125;else &#123; return a - b; //此时a - b为负数 &#125;&#125;)console.log(arr); //[1, 2, 5, 8, 10, 61] 实现的原理为：第一个数依次和后面的数比较，找到最小的数放在第一个； 第二个数依次和后面的数比较，找到第二小的放在第二个; 依次类推，直到元素有规律排列为止。 按照上面的原理，会发现他其实和选择排序的原理是一样的。 选择排序的原理：数组里面的第一个数依次和后面的数作比较，如果后面的数小于第一个数，交换顺序(找出最小的放在第一位); 再选出第二个数依次和后面的数作比较，选出余下数组里面最小的放在第二位； 重复以上规律，直到数组有序为止。 具体实现如下：12345678910111213141516var arr = [10, 5, 8, 2, 61, 1];function selectSort (arr) &#123; var temple; for (var i = 0; i &lt; arr.length - 1; i++) &#123; //取出数组每一位 for (var j = i + 1; j &lt; arr.length; j++) &#123; //循环次数 if (arr[i] &gt; arr[j]) &#123; temple = arr[i]; arr[i] = arr[j]; arr[j] = temple; &#125; &#125; &#125; return arr;&#125;console.log(selectSort(arr)); //[1, 2, 5, 8, 10, 61] 综上所述，最终可以把arr.sort()总结为：(1)默认对字符进行排序，直接调用arr.sort(); (2)升序排列(从小到大)123arr.sort(function (a, b) &#123; return a - b;&#125;) (3)降序排列(从大到小)123arr.sort(function (a, b) &#123; return b - a;&#125;) 应用：将数组乱序排列，每次乱序的结果不一致。具体实现如下：1234567var arr = [10, 5, 8, 2, 61, 1];setInterval(function () &#123; arr.sort(function (a, b) &#123; return Math.random() - 0.3; &#125;) console.log(arr);&#125;, 500) 运算结果如下： Math.random()产生随机数，随机数的范围为[0, 1);当Math.random() - 0.5，随机数的范围为[-0.5, 0.5)。 调用arr.sort()，当返回正数时，a, b交换顺序；返回负数时，a, b顺序不变。]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的模块]]></title>
    <url>%2F2018%2F10%2F11%2Fjs%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[在一个项目中，可能同一个功能会在不同的地方用到过，为了节约开发成本，于是我们主张模块化开发。 这样不但使重复的功能可以直接复用，而且避免了多人协作开发时引入同名变量造成错误的尴尬。 在js中模块通常有两种形式，函数模块和ES6中的模块。 函数模块在js中有这样的概念，主张语义化开发，尽可能少的暴露全局变量。这样做的原因是： (1)避免全局变量污染。在同一个文件里面定义多个同名的变量可能会导致变量覆盖，以致于调用的方法错误。 (2)优化代码性能。浏览器在处理时，会把定义在全局的变量挂载到window的属性下，每次查找变量时，会依次查找window下的属性，过多的全局变量会导致查找变量的时间越来越长。 所以在js中就有了用函数来封闭作用域的现象。 函数模块就是把要实现的功能封闭在一个函数里，最后导出一个接口来供外部环境调用。他需要满足以下两个条件： (1)必须有外部的封闭函数; (2)封闭函数必须返回至少一个内部函数。 具体的举例如下：12345678910111213141516171819function func () &#123; var n = 1; var arr = [8, 5, 6] function add() &#123; n += 1; console.log(n); &#125; function arrSort() &#123; console.log(arr.sort()); &#125; return &#123; add: add, arrSort: arrSort &#125;&#125;var foo = func();foo.add(); //2foo.arrSort(); //[5, 6, 8] 这个返回的对象中含有对内部函数的引用。内部数据变量仍然是隐藏的私有状态(只有函数内部可以被访问到)。 在这里将返回的对象赋值给foo, 因此就可以通过访问对象属性名的方式来访问到函数里面方法。 从模块中返回一个对象并不是必须的，也可以直接返回一个内部函数。 上面是通过函数调用的方式将返回的对象赋值给一个外部变量来调用执行。该方法可以被调用多次，执行多次。 如果只是想只执行一遍函数的运算过程，保留函数的运行结果来调用的话，可以选择立即执行函数。 代码修改如下：123456789101112131415161718var foo = (function () &#123; var n = 1; var arr = [8, 5, 6] function add() &#123; n += 1; console.log(n); &#125; function arrSort() &#123; console.log(arr.sort()); &#125; return &#123; add: add, arrSort: arrSort &#125;&#125;)()foo.add(); //2foo.arrSort(); //[5, 6, 8] 当想要给函数传参时，也是像以前立即函数正常的处理逻辑。 ES6的模块通过上面的内容我们了解到，所谓模块大概就是封装一个接口，导出一个变量(接口)来实现的。在ES6中也是一样，只不过可能导入导出的方式发生了改变。 ES6中的模块必须被定义在一个独立的文件中(一个文件一个模块)，浏览器在加载时可以同步的导入模块。 具体举例如下：123456789101112131415161718192021//myInform.js文件function person (name) &#123; return name;&#125;export person;//sayHello.js文件import person from &quot;myInform&quot;;var myName = &apos;fs&apos;;function hello () &#123; console.log(&apos;Hello &apos; + person(myName));&#125;export hello;//all.js文件module myInform from &quot;myInform&quot;;module sayHello from &quot;sayHello&quot;;console.log(myInform.person(&apos;ll&apos;)); //llsayHello.hello(); //Hello fs import可以将模块中的一个或多个API导入到当前的作用域中，并分别绑定在一个变量上(person)。 module会将整个模块的API导入并绑定到一个变量上(myInform, sayHello)。 export会将当前模块的一个接口(变量，函数)导出为公共API。 函数模块和ES6模块的区别基于上述两种形式，考虑到ES6是JS的升级版，所以肯定是在函数模块的基础上进行了优化。 具体区别如下： 函数模块只有在函数运行时里面的代码才会被考虑进来，因此可以在代码运行时修改代码的API。 ES6模块在编译时会被导入模块的API检查是否真的存在。如果导入的API不存在，则编译器直接报错。]]></content>
      <categories>
        <category>模块</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES6</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试易错题整理]]></title>
    <url>%2F2018%2F10%2F08%2F%E7%AC%94%E8%AF%95%E6%98%93%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[答笔试题就像是一个翻山越岭的过程，迈过了大坑又迈小坑，很多时候以为自己跨过重重险阻终于要成功时，却一不小心就入了出题者的坑。 下面是我整理的一些面试中我遇到的易错题，有的问题我也不是特别清楚，欢迎大家各抒己见。 写出下面程序的运行结果 (1)函数的执行环境123456789101112131415var str = &apos;hello&apos;;var fn1 = function () &#123; console.log(str); //HELLO&#125;str = &apos;HELLO&apos;;var fn2 = function () &#123; var str = &apos;world&apos;; fn1(); str = &apos;WORLD&apos;;&#125; fn2(); 函数能访问到变量的作用域和函数定义时的环境有关。与函数执行环境无关(只有函数中含有this时，才需要注意函数的执行环境)。 函数fn1是在全局定义的，且定义时函数内部并没有定义变量，他能访问到的变量的作用域是全局window下的。 (2)Date时间问题12345678let message = &quot;Hi&quot;;let start = new Date();wait = (message) =&gt; &#123; setTimeout(() =&gt; console.log(message), 1000);&#125;wait(&quot;Hello&quot;);while (new Date() - start &lt; 1000) &#123;&#125;;console.log(&quot;Tom&quot;); 输出结果：首先，定时器是异步的，js是单线程的，所以定时器里面的内容会被添加到任务队列里。所以输出顺序应该是先输出Tom再输出Hello。 至于为什么while循环没有陷入死循环能继续执行后面的代码呢？可以在上面代码的基础上while循环之前打印console.log(new Date() - start)会发现每次的值都不确定，大多是0，但是值一定是小于1000的。 于是可以在循环里面打印出所有的值来查看，在上面的基础上修改代码如下：123while (new Date() - start &lt; 1000) &#123; console.log(new Date() - start);&#125;; 在浏览器看打印结果(结果只截取了部分)：会发现每次获取的结果都是不确定的，唯一可以肯定的就是结果是随获取的时间顺序递增的。我想可能是跟浏览器的刷新速度有关，浏览器每隔16ms刷新一次。 (3)数组的复制及清空123456789var a = [6, 7, 8];var b = a; //[6, 7, 8](function (x) &#123; x.length = 0; //[],把数组a清空 x.push(2, 3, 4, 5);&#125;(a))console.log(a); //[2, 3, 4, 5]console.log(b); //[2, 3, 4, 5] 数组存在栈里，复制时，复制的是引用值的地址。当一个值发生改变时，另外一个值也会发生改变。x.length = 0可以将数组清空为空数组。 (4)闭包123456789101112function func () &#123; var i = 0; return function () &#123; console.log(i++); &#125;&#125;var func1 = func(), func2 = func();func1(); //0func1(); //1func2(); //0 考察闭包。一个函数(func)的执行结果是返回另外一个函数(return function ())，返回出去的函数任然能访问到原来的作用域链(变量i)。 func1和func2保存的都为func的执行结果，即返回出去的函数return function，func1和func2互不影响。 func1()执行时，第一次访问到的i为函数func里面声明的变量i。第二次执行时，访问到的i为第一次func1()的执行结果，即i++。 需要注意前置++和后置++的执行顺序，前置++为先++再输出，后置++为先输出后++。这里如果改为console.log(++i);输出顺序应该是1, 2, 1 (5)类似考察闭包的还有：1234567891011121314function f1 () &#123; var n = 99; add = function () &#123; n += 1; &#125; function f2 () &#123; console.log(n); &#125; return f2;&#125;var result = f1();result(); //99add();result(); //100 函数f1()的执行结果是返回f2，f2任能访问到原来的作用域链。add执行时与执行环境无关，看原来的定义环境，能访问到i。所以第二次result()的执行结果为add()执行后的i (6)定时器里的闭包123456789101112let i = 0;var j = 0;var k = 0;for(; i &lt; 10, j &lt; 6; i++, j++) &#123; setTimeout(() =&gt; &#123; k = i + j; console.log(i, j, k) &#125;, 0)&#125;setTimeout(() =&gt; &#123; console.log(k)&#125;, 100) ！！！！当for循环和定时器(异步操作)联系在一起时，一定要考虑到闭包问题。 for循环每次的执行结果是返回一个定时器setTimeout()。当j == 6时，是for循环终止的条件，此时i == j == 6;k = i + j。访问到的i, k, j都是满足for循环终止条件的最后一次的值。 输出结果： (7)关于this指向1234567891011121314151617181920var id = 21;var obj = &#123; id: 22&#125;function fn1 () &#123; setTimeout(function () &#123; console.log(this.id); &#125;)&#125;fn1(); //21fn1.call(obj); //21function fn2 () &#123; setTimeout(() =&gt; &#123; console.log(this.id); &#125;)&#125;fn2(); //21fn2.call(obj); //22 关于this指向，call()第一个参数用来改变this指向，后面的值为实参。 (8)全局环境下的this123456789101112function foo (num) &#123; console.log(num); console.log(&apos;foo&apos;, this.count++);&#125;foo.count = 0;for (var i = 0; i &lt; 8; i++) &#123; if(i &gt; 3) &#123; foo(i); &#125;&#125;console.log(&apos;win&apos;, this.count); 函数foo()执行时是在for循环里即全局window下执行的，此时this指向window。this.count =&gt; window.count，用window.count的方式访问一个全局没有声明的变量时，会把该变量当做全局window的属性挂载到全局window下，此时访问该变量的值为undefined。 ++默认会有隐式转换，即把变量转换为数字类型再进行计算，此时undefined =&gt; NaN，所以打印出的this.count为NaN. this.count一共经历的转换过程为：this.count =&gt; window.count =&gt; undefined =&gt; NaN. 执行结果： 当变量在全局已经声明时：1234567891011121314var count = 0;function foo (num) &#123; console.log(num); console.log(&apos;foo&apos;, this.count++);&#125;foo.count = 0;for (var i = 0; i &lt; 8; i++) &#123; if(i &gt; 3) &#123; foo(i); &#125;&#125;console.log(&apos;win&apos;, this.count); 用window.count的方式访问一个全局已经声明的变量时，window.count =&gt; count，此时直接找到count的值进行相应计算即可。 执行结果： (9)对象的解构赋值及原型链1234567let x = &#123;a: 3&#125;;let obj = &#123; __proto__: null, b: 2, ...x &#125;console.log(obj); 输出结果如下： (10)数组的解构赋值1234let [x, y, ...z] = [&apos;a&apos;];console.log(x); //aconsole.log(y); //undefinedconsole.log(z); //[] (11)函数执行时的预编译123456var b = 3;(function () &#123; b = 4; var b = 5;&#125;)();console.log(b); //3 在全局作用域声明b = 3;在函数里面也声明了b, 根据函数的执行顺序，声明b时，其值为undefined。当b = 4时，会在函数里面查找是否声明过变量b,如果声明过，则将函数里面b的值由undefined转换为4。 这并不是通常所说的在函数里面没有var则代表隐式声明全局作用域b。当函数里面没有声明过b时，则为隐式声明全局变量b。如下： 123456var b = 3;(function () &#123; b = 4; var c = 5;&#125;)();console.log(b); //4 (12)预编译和逻辑运算符123456789101112131415var foo = &apos;hello&apos;;(function () &#123; var foo = foo || &apos;world&apos;; console.log(foo); //world&#125;)();(function (fn) &#123; var foo = fn || &apos;world&apos;; console.log(foo); //hello&#125;)(foo);(function () &#123; console.log(foo); //undefined var foo = foo || &apos;world&apos;;&#125;)(); 此题与函数执行时查找变量的顺序有关。(1) || (2)找到真为止，(1)为假时，继续执行(2), 并把(2)的计算结果输出。]]></content>
      <categories>
        <category>易错点整理</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平垂直居中对齐]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[实现元素的水平垂直居中对齐是页面布局中很常用的一种方法。一般要实现垂直居中的元素可以是文字，某个块级元素，或者是图片。 初始化页面高度在开始前，需要补充的一个知识点是：如何让页面高度刚好占满屏幕高度？ 若想让一个div的高度与屏幕高度自适应，始终占满屏幕高度，需要从html层开始层层添加height: 100%，如下：1234567891011121314&lt;div class=&quot;wrapper&quot;&gt;&lt;/div&gt;&lt;style&gt; html, body&#123; height:100%; width:100%; margin:0; padding:0; &#125; .wrapper &#123; height: 100%; background: #ddd; &#125;&lt;/style&gt; html没有padding和margin，body没有padding有margin，块级元素宽度默认占满整行，所以上面的代码也可以改为：123456789101112131415&lt;div class=&quot;wrapper&quot;&gt;&lt;/div&gt;&lt;style&gt; html &#123; height: 100%; &#125; body &#123; height: 100%; margin: 0; &#125; .wrapper &#123; height: 100%; background: #ddd; &#125;&lt;/style&gt; 行级元素的居中水平居中1234567891011&lt;div class=&quot;wrapper&quot;&gt; &lt;span&gt;要设置的文字&lt;/span&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; width: 300px; border: 1px solid black; text-align: center; &#125;&lt;/style&gt; 要居中的元素包在块级父层元素内，设置父级text-align: center;行级块元素也可以水平居中(img，input)。 垂直居中123456789101112&lt;div class=&quot;wrapper&quot;&gt; &lt;span&gt;要设置的文字&lt;/span&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; width: 300px; height: 100px; border: 1px solid black; line-height: 100px; &#125;&lt;/style&gt; 此方法通过给父级(或元素本身)设置line-height等于父级的高度来实现元素的垂直居中。适用于父级高度已知时，给单行文本设置垂直居中。img标签不适用此方法。 水平垂直居中12345678910111213&lt;div class=&quot;wrapper&quot;&gt; &lt;span&gt;要设置的文字&lt;/span&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; width: 300px; height: 100px; border: 1px solid black; line-height: 100px; text-align: center; &#125;&lt;/style&gt; 父级高度已知的单行文本设置水平垂直居中，通过text-align: center;和line-height等于父级高度来实现。 块级元素的居中水平居中(1)适用于单个块级元素，当左右边距设置为auto时可以设置水平居中12345678910&lt;div&gt;&lt;/div&gt;&lt;style&gt; div &#123; width: 100px; height: 100px; border: 1px solid black; margin: 0 auto; &#125;&lt;/style&gt; 页面显示如下： (2)设置元素为行级块元素，让元素根据自身大小占据空间。然后给父级设置text-align来实现子级元素在父级元素水平居中1234567891011121314151617181920&lt;div class=&quot;father&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; text-align: center; &#125; .father div &#123; display: inline-block; width: 100px; height: 100px; background: orange; &#125; .father div:not(:last-child) &#123; margin-right: 10px; &#125;&lt;/style&gt; :not()除什么之外，当有多个元素时，如果给每个子级div都设置右边距时最后一个元素后边相应的也会有边距。然后总体来看就是第一个元素的左边和最后一个元素的右边剩余的大小是不一致的。所以最后一个元素不用设置右边间距。 页面显示如下： (3)flex布局，最常用的居中方式1234567891011121314151617181920&lt;div class=&quot;father&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; display: flex; justify-content: center; &#125; .father div &#123; width: 100px; height: 100px; background: green; &#125; .father div:not(:last-child) &#123; margin-right: 10px; &#125;&lt;/style&gt; 主要就是通过给父级元素设置display: flex;属性为弹性弹性元素，然后设置主轴justify-content对齐方式为居中对齐。 页面显示如下： 水平垂直居中如果想让元素刚好在屏幕最中央，需要先对页面进行初始化，让div元素刚好占满屏幕高度来实现页面布局。123456789&lt;style&gt; html &#123; height: 100%; &#125; body &#123; height: 100%; margin: 0; &#125;&lt;/style&gt; 在将页面初始化后，可以通过以下几种方式来实现元素的垂直水平居中。如果不想要元素在整个页面中垂直居中，可以通过调节父级元素的宽高来设置。 (1)绝对定位 + 负边距实现(需要知道设置的元素的宽，高)123456789101112131415161718192021&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; position: relative; height: 100%; background: #ddd; &#125; .son &#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; background: red; margin-top: -50px; margin-left: -50px; &#125;&lt;/style&gt; 父级相对定位，子级绝对定位，子级相对于父级来挪动位置。当给子级设置top: 50%和left: 50%时子级的左顶点刚好在父级中心，所以子级需要相对父级左移，上移。设置子级margin-top和margin-left为自身高度和宽度的负的一半。 页面显示如下： 以下几种方法无需知道被居中元素的大小： (2)绝对定位 + css312345678910111213141516171819&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; position: relative; height: 100%; &#125; .son &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; background: green; &#125;&lt;/style&gt; translate(-50%,-50%) 作用是：往上（x轴）,左（y轴）移动自身宽度，高度的 50%，以使其居于中心位置 页面显示如下： (3)绝对定位 + margin123456789101112131415161718192021&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; position: relative; height: 100%; &#125; .son &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 100px; height: 100px; background: blue; &#125;&lt;/style&gt; 子元素相对父元素绝对定位，margin设置为auto时默认只能在水平方向上居中。只有给元素设置top, left, right, bottom时才能看到父级元素的宽和高，此时再设置margin: auto;元素就能根据父级进行居中 页面显示如下： (4)margin + flex12345678910111213141516&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; display: flex; height: 100%; &#125; .son &#123; width: 100px; height: 100px; background: orange; margin: auto; &#125;&lt;/style&gt; margin: auto只能设置水平方向上的居中，所以如果要在垂直方向上居中。首先，需要设置父级高度，然后设置父级为display: flex 页面显示如下： (5)flex布局，最常用的布局方式1234567891011121314151617&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; display: flex; justify-content: center; align-items: center; height: 100%; &#125; .son &#123; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 给父级容器设置为弹性盒子，主轴(水平方向)设置justify-content: center，交叉轴(垂直方向)设置align-items: center即可实现元素水平垂直居中。 其中，这两个属性都是需要设置在父级容器上才会生效。 页面显示如下：]]></content>
      <categories>
        <category>页面布局</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐式类型转换]]></title>
    <url>%2F2018%2F09%2F24%2F%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[你可能见到过这样的情况：”5” - 3 == 2和”5” + 3 == “53”，可是这是为什么呢？ 上节提到过关于强制类型转换到的概念，通过调用方法来实现数据在不同类型间的转换。同样的，既然有强制类型转换，那么也会有隐式类型转换。 隐式类型转换转换为数字类型进行比较运算。以下几种情况会有数据的默认转换： isNaN()翻译过来意思就是：是NaN吗？此方法会先调用Number()的方法将数据转化为数字类型来进行比较。 数字类型包括四个值：具体的数字，NaN，Infinity，-Infinity 如果转换为数字时，返回的值刚好是NaN，则调用isNaN()时返回true。 具体步骤为：isNaN(demo) =&gt; Number(demo) =&gt; NaN =&gt; true / false 1234isNaN(23) //falseisNaN(&apos;a&apos;) //trueisNaN(NaN) //trueisNaN(null) //false 当调用Number()数据是怎么转换的，可以参考上一篇(强制类型转换)。Number(null)值为0 ++/- -, +/-++ / - - 分为前置++和后置++，区别在于变量的输出顺序不同。+/- 为一元正负运算符，并不是通常所说的数学中的加和减。即+4, -3 123+3 //3-5 //-5+&apos;a&apos; //NaN 12var str = &apos;a&apos;;console.log(str ++); //NaN 算数运算符‘+ , - , * , / , % (取余) ‘会将符号两边的值转换为数字进行运算 123456null + 1 //1&quot;abc&quot; + 1 //&quot;abc1&quot;&quot;2&quot; * &quot;a&quot; //NaN8 - &quot;2&quot; //65 / &quot;3&quot; //1.66666666666666675 % &quot;3&quot; //2 需要注意的是： + 号遇到字符串时，相当于字符串的拼接，他会把加号另外一边不是字符串的值转化为字符串，并和已知的字符串进行拼接。 如果没有字符串时，则将 + 两边的值正常转换为数字类型来进行计算。 1232 + &quot;&quot; //&quot;2&quot;2 + &quot; &quot; //&quot;2 &quot;2 + &quot;5&quot; //&quot;25&quot; 空串””和空格字符串” “的区别在于其布尔值，空串””为false，空格字符串” “为true 逻辑运算符‘ &amp;&amp;(与) ， ||(或) ， !(非) ‘输出运算结果。运算结果为真实的值(1) &amp;&amp; (2)：找到假为止。他会先取出(1)表达式的值，看是否为真。(1)为真,继续执行(2)，不管(2)结果为真还是为假都输出(2)表达式的运算结果。(1)为假，输出(1)表达式的运算结果。 (1) || (2)：找到真为止。他会先取出(1)表达式的值，看是否为真。(1)为真，输出(1)表达式的运算结果。(1)为假，继续执行(2)，不管(2)结果为真还是为假都输出(2)表达式的运算结果。 !(1)：取反。(1)运算结果为真时，取反则为假。(1)为假，取反为真。 1231 &amp;&amp; 2 //2&quot;a&quot; || NaN //&quot;a&quot;!4 //false 比较运算符‘ &gt; , &lt; , &gt;= , &lt;= , == , != ‘比较结果为布尔值 1234561 == &quot;1&quot; //true&quot;a&quot; &gt; &quot;b&quot; //false0 == &quot;&quot; //true0 == false //trueundefined == null //trueNaN == NaN //false 字符串和数字比较时，会将字符串转化为数字进行比较。字符串比较时，比较的为ASCII值。 根据undefined和null的特殊性质(undefined和null不等于0，不大于0，不小于0)，所以让他们两个相等。 NaN不等于任何值，包括他自身。 不发生类型转换===(绝对等于) , !==(绝对不等于)121 == &quot;1&quot; //true1 === &quot;1&quot; //false 小练习1211 + &quot;11&quot; //&quot;1111&quot;undefined == NaN //false 1234567var str = &quot;abc&quot;;str += 1; //&quot;abc1&quot;var test = typeof(str); //&quot;string&quot;if (test.length == 6) &#123; //new String(str).length = 6; =&gt; delete test.sign = &quot;typeof的返回值可能为string&quot; &#125;console.log(test.sign); //undefined 包装类。强行给原始值加上某个属性时可以加上，但是实际访问时并不存在。所以if的条件并不成立，即不能给test加上sign属性。 12345var str = false + 1; console.log(str); //1var demo = false == 1;console.log(demo); //false 有赋值和比较运算符时，先比较后赋值。即false != 1, 比较运算符，输出结果为布尔值。 1typeof typeof(undefined); //&quot;string&quot; 123if (typeof(a) &amp;&amp; -true + (+undefined) + &quot;&quot;) &#123; console.log(&quot;hello&quot;); //hello&#125; typeof(a)返回值为”undefined”，数据类型为字符串，为真。接着逻辑运算符后面的代码，-true + (+undefined) + “” =&gt; -1 + NaN + “” =&gt; NaN + “” =&gt; “NaN”，为字符串类型，为真，执行if里面的条件语句。 12345if (11 + &quot;11&quot; * 2 == 33) &#123; console.log(&quot;smile&quot;); //smile&#125;!!&quot; &quot; + !!&quot;&quot; - !!false || console.log(&apos;no&apos;); //1 + 0 - 0 =&gt; 1 123[3 &lt; 1 &lt; 2, 1 &gt; 2 &gt; 3]; //[true, false][3 &lt; 1 &lt; 2, 3 &lt; 1 &lt;= 0]; //[true, true] 当有多个比较运算符时，从左到右两个值一起进行比较，并将第一次比较的结果和第二次比较运算符右边的值作比较。 3 &lt; 1 &lt; 2比较时就是先让3和1比，3 &gt; 1，所以第一个比较的结果返回false(0)，然后再让0和后面的2比，0 &lt; 2, 所以比较结果为真，返回true。 也就是3 &lt; 1 &lt; 2 =&gt; 0(false) &lt; 2 =&gt; true]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制类型转换]]></title>
    <url>%2F2018%2F09%2F23%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在js里面声明变量时并没有直接定义该变量是什么类型，变量的类型由为他赋值时所定义的值所决定(var num = 123,定义了该变量为数字)。 但是有这么一种情况，当我们需要的变量是一个数字类型，但用户输入时给定的却是一个字符串。除了给用户提示输入正确的数据类型外，是否可以从前端的角度做一些关于数据类型的处理？ 这就出现了数据类型的转换。当一个变量从某种类型转化为另外一种类型时，则可以调用对应变量类型的方法。 强制类型转换针对js中的数据类型原始值(number，string，boolean，undefined，null)和引用值(array，object，function)，当不同的数据类型调用不同的方法时，看其相应的返回值。 Number()该方法会把任意类型的数据转换为数字类型。 数字类型包括四个值：具体的数字，NaN，Infinity，-Infinity1234567Number(123.0) //123Number(0.300) //0.3Number(030) //30Number(0/0) //NaNNumber(1/0) //InfinityNumber(-1/0) //-InfinityNumber(6/2) //3 当输入具体数据时，直接输出数据。但是会对数据做以下处理：(1)如果数字的最高位为0，删除最高位的0，返回有效的数据(2)如果小数点后面有0，删除小数点后面无效的0(3)如果输入的数据需要计算，则返回最后的计算结果 123Number(&apos;123&apos;) //123Number(&apos;abc&apos;) //NaNNumber(&apos;123abc&apos;) //NaN 当输入字符串时，会出现3种情况：(1)输入的字符串为纯数字，则返回具体数字(2)输入的字符串为纯字符，则直接返回NaN(3)输入的字符串同时包含数字和字符，返回NaN 12Number(true) //1Number(false) //0 当输入布尔值时，true =&gt; 1，false =&gt; 0 12Number(undefined) //NaNNumber(null) //0 需要注意的是，输入null时返回的是0 123Number(&#123;a:1,b:2,c:&#123;d:1&#125;&#125;) //NaNNumber([1,2,3]) //NaNNumber([1]) //1 输入引用类型的数据时，返回的值为NaN。 但有一种特殊的情况就是当要转换的变量为数组，切数组的长度为1时，该数据类型可以直接转换为相应的数据 parseInt()该方法趋向于将字符串转换为数字类型。12parseInt(112) //112parseInt(112.14) //112 输入数字时，该方法会有截取的功能，截取数字的整数部分。 即可以调用该方法将数字直接转化为整型数字(没有小数) 123parseInt(&apos;112&apos;) //112parseInt(&apos;112px&apos;) //112parseInt(&apos;abc&apos;) //NaN 当输入字符串时，会出现3种情况：(1)输入的字符串为纯数字，则返回具体数字(2)输入的字符串为纯字符，则直接返回NaN(3)输入的字符串同时包含数字和字符，该方法会有截取的效果。则从第一个字符串开始，到非数字位截止。返回截取的数字部分 1234567parseInt(true) //NaNparseInt(undefined) //NaNparseInt(null) //NaNparseInt(&#123;a:1&#125;) //NaNparseInt(&#123;1:1&#125;) //NaNparseInt([1]) //1parseInt([1,2]) //1 当变量类型为引用值时，直接返回NaN。但需要注意的是，当定义的数组为第一位为数字时，返回该数组的第一位。 该方法的关键在于，趋向于将字符串转换为数字。当定义的变量不是字符串时，通常返回NaN(数字直接返回截取后的值。数组第一位为数字时，直接返回数组第一位) 该方法还可以传第二个参数，parseInt(num, radix)表示num是radix进制的数据，以radix为基底将num转换为十进制的数字。1parseInt(&apos;123a&apos;, 16) //4666 该例子表示将16进制(包括0-9, a-f)的123a转换成十进制对应的数据 12parseInt(&apos;112&apos;, 2) //3parseInt(&apos;121&apos;, 2) //1 当要转换的数据超出了该进制所包含的值时，会从超出进制的数据位对该数据进行截取，再对截取后的数据调用该方法进行转换。 将’112’的二进制转换为十进制的数据时，因为二进制只能包括0和1，所以会对’112’进行截取，截取后的数据为’11’，再将’11’转化为十进制 parseFloat()将字符串转换为数字类型，parseInt()不同的是：(1)可以在parseInt()的基础上保留一个小数点，即可以将数据转化为浮点型(含有小数)并去除无效的0(2)没有第二个参数，即没有进制间的转换 12parseFloat(&apos;123.020&apos;) //123.02parseFloat(&apos;123.020.21&apos;) //123.02 以上三个方法都是将变量转换为数字。 Boolean()将变量转换为布尔值(0或1)12Boolean(123) //trueBoolean(&quot;&quot;) //false 转换成布尔值为false的有：NaN, 0, “”, false, undefined, null 其他值转换为布尔值均为true String()将变量转化为字符串 1234String(123) //&quot;123&quot;String(true) //&quot;true&quot;String(undefined) //&quot;undefined&quot;String(null) //&quot;null&quot; 将任意类型直接转换为字符串，即相当于num + “” toString()将变量转化为字符串，除undefined, null(没有原型) 12.toString() //error 这里趋向于变量调用该方法进行转换，数字直接调用时会报错。 如果传入的数据为数字类型时，应该采用如下方式处理：1var num = 3;num.toString() //&quot;3&quot; 12var num = 070; num.toString() //56var num=0110;num.toString() //&quot;72&quot; 当数字第一位为0时，会被默认为八进制，然后将其转换为十进制。即将八进制的070转换为十进制 再看以下例子：1233.toString() //error3..toString() //&quot;3&quot;3...toString() //error, Unexpected token . 3..toString()中，3..相当于3.0来调用toString()的方法进行转换。 换句话说就是，如果数字直接调用toString()方法时，只有数字类型为小数(浮点型)才不会报错。否则都应该以变量声明的形式来调用。 1233.1.toString() //&quot;3.1&quot;3.0.toString() //&quot;3&quot;3.900.toString() //&quot;3.9&quot; 该方法可以去除小数点后面无效的0 再看其他类型的数据调用该方法时：1234true.toString() //&quot;true&quot;undefined.toString() //err[1,2].toString() //&quot;1,2&quot;&#123;a: 1, b: 2&#125;.toString() //err 通过以上例子我们发现，当数组调用toString()方法时，会将数组直接转换为字符串。 但以上数组的组成均为数字，如果数组中含有其他类型的变量时，是否依然成立呢？123[1, 2, &apos;a&apos;, &apos;b&apos;, 8].toString() //&quot;1,2,a,b,8&quot;[1, [4, &apos;a&apos;], &#123;b : 1&#125;, &apos;c&apos;].toString() //&quot;1,4,a,[object Object],c&quot;[1, undefined, &apos;b&apos;, null].toString() //&quot;1,,b,&quot; 首先，null, undefined是不能调用toString()方法的，直接调用时报错。在数组中调用时，数组对应的位置为空。 对象调用toString()方法也直接报错，在数组中时，返回该数据的类型[object Object]。 该方法还可以传第二个参数，variable.toString(k)表示将十进制的variable转换为k进制的数据，即将十进制转换为k进制1var num = 123; num.toString(16) //&quot;7b&quot; 再看以下例子：将二进制10101010转换为16进制的数据 分析题目并结合以上知识点可以想到，先将二进制的数据转换为十进制，再将十进制转化为十六进制1234var num2 = 10101010;var num10 = parseInt(num2, 2);var num16 = num10.toString(16);console.log(num16); //&quot;aa&quot;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typeof返回值]]></title>
    <url>%2F2018%2F09%2F22%2Ftypeof%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[js基本数据类型js里面基本数据类型分为原始值和引用值两大类。 其中原始值包括数字number，字符串string，布尔值boolean，undefined，null五种。 引用值包括数组array，对象object，函数function三种。 typeof判断数据类型当传入一个变量时，可以用typeof来判断基本的数据类型。 根据传入的数据类型进行划分，typeof的返回值包括”number” ，”string” ，”boolean” ，”undefined” , “object” ， “function”六种 其调用形式如下：(1)typeof num(2)typeof(num) 其中，typeof后面跟的为需要判断数据类型的变量。传入的变量可以直接跟在typeof后面以空格分隔开，也可以直接写在括号里 看如下例子：123typeof 123; //&quot;number&quot;typeof NaN; //&quot;number&quot;typeof Infinity; //&quot;number&quot; 但凡是数学计算能产生的结果都是数字类型，数字类型的返回值为”number” 12345var str = &apos;123abc&apos;;typeof str; //&quot;string&quot; typeof +str; //&quot;number&quot;typeof !!str; //&quot;boolean&quot;typeof str + &apos;&apos;; //&quot;string&quot; 输入一个字符串，字符串可以通过运算符改变其类型，typeof会根据类型返回特定的值 1typeof a; //&quot;undefined&quot; 在js中，一个变量未经声明就使用，只有在一种情况下不会报错，那就是将变量放在typeof里面查看类型 综上总结，可以将基本数据类型和typeof的返回值做如下对应关系：typeof的返回值: “number” ，”string” ，”boolean” ，”undefined” , “function” ，”object”返回值为”number”包括：数字类型(number)返回值为”string”包括：字符串类型(string)返回值为”boolean”包括：布尔值(boolean)返回值为”undefined”包括：undefined(即值未定义)返回值为”function”包括：函数function比较特殊的是，返回值为”object”包括：null，数组array，对象object 所以当需要判断具体的”object”类型时，需要对null，array，object进行判断 注意点typeof的返回值均为字符串，即number类型的字符串，string类型的字符串，boolean类型的字符串，undefined类型的字符串，function类型的字符串，object类型的字符串 即typeof(typeof “number”) =&gt; “string” 特殊情况考虑以下情况，当基本数据类型的首字母大写时，相应的typeof是否也会发生改变呢？12345678typeof Number //&quot;string&quot;typeof String //&quot;string&quot;typeof Boolean //&quot;string&quot;typeof Undefined //&quot;undefined&quot;typeof Null //&quot;undefined&quot;typeof Array //&quot;string&quot;typeof Object //&quot;string&quot;typeof Function //&quot;string&quot; 总结起来就是返回值为”string”包括：Number / String / Boolean / Array / Object / Function返回值为”undefined”包括：Undefined / Null]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>typeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行内元素和块级元素]]></title>
    <url>%2F2018%2F09%2F21%2F%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[元素分类块级元素(block)常用元素：div / p / ul / li / ol / form / address / h(h1-h6) 特点：元素独自占据一整行，可以给元素设置宽和高 具体设置如下：12345678910111213&lt;div class=&quot;red&quot;&gt;&lt;/div&gt;&lt;div class=&quot;blue&quot;&gt;&lt;/div&gt;&lt;style&gt; div &#123; width: 100px; height: 100px; background: red; &#125; .blue &#123; background: blue; &#125;&lt;/style&gt; 在浏览器中展示如下：可以看到，第一个div的宽度只有100px, 但是他占据了浏览器的一整行。使得第二个div换行展示 行内元素(inline)常用元素：span / a / em / del / strong 特点：根据自身内容占据空间大小，不能给元素设置宽和高 具体设置如下：12&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 在浏览器中展示如下：可以看到，span根据自身的内容占据了相应的大小，后面的span紧挨着进行展示 行级元素虽然不可以设置宽高，但可以给他设置字体大小(font-size)，字体颜色(color)，字体样式(font-family)等和字体相关的属性 行级块元素(inline-block)也叫内联元素，常用元素：img / input 特点：根据自身内容占据大小，又可以给元素设置宽和高 具体设置如下：12345678910&lt;input type = &quot;text&quot;&gt;&lt;input type = &quot;text&quot;&gt;&lt;style&gt; input &#123; width: 200px; height: 30px; margin-right: 30px; &#125;&lt;/style&gt; 在浏览器中展示如下： 行级块元素input设置了宽和高，第一个input占据的宽度仅为设置的宽度，第二个input紧挨着第一个进行展示 行级块元素通常会被分类在行内元素里面 相互转换关系块级元素默认display: block 行内元素默认display: inline 行级块元素默认display: inline-block 当给块级元素设置display: inline或设置display: inline-block时，块级元素可以转换为行内元素或者行级块元素，并具有行级元素或行级块元素独有的特性。以此类推。 注意点margin和padding为复合属性，默认顺序为(上 右 下 左)。 块级元素的margin值包括(margin-top, margin-right, margin-bottom, margin-left)，padding值包括(padding-top, padding-right, padding-bottom, padding-left) 但行内元素只有margin-left, margin-right, padding-left, padding-right值 根据默认margin和padding分类只有默认margin值：body / p / form h(h1-h6) 只有默认padding值：input / img / textarea / button 有默认padding和margin：ol / ul 没有默认padding和margin：div / span body默认有8px的margin值 只有清除默认的padding和margin值我们设置的css样式才不会有偏差，样式才能布满整个页面 常用的处理方式：一般在css全局里面定义以下代码：1234* &#123; padding: 0; margin: 0;&#125; 也可以在总样式文件里面定义如下内容：1body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, textarea, p, blockquote, th, td, img &#123;padding: 0; margin: 0;&#125; 即选出css中可能用到的具有margin和padding的标签，将其初始化]]></content>
      <categories>
        <category>元素分类</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>行内元素</tag>
        <tag>块级元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组扁平化]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[你可能会看到这样一种情况，大概的描述就是一个数组里面包含了很多了数组，数组里面还可以再包含数组。或者是一个数组里面包含了很多个对象。 我们通常需要的只是一维的数组，此时就需要将数组降维进行扁平化处理。 数组的数据结构如下：1var arrObj = [&#123;x: 1&#125;, &#123;y: 2&#125;, &#123;z: 3&#125;]; 需要将以上数组转化为一维的对象，如下： 在开始前需要先了解以下知识点： (1)forEach(ele, index, arr) 有三个参数，第一个为数组的每一项，第二个为当前元素的索引，第三个为原来的数组(即调用forEach的那个数组)。也可以传入第四个参数，代表this指向。 该方法和for循环的区别是： forEach()循环没有办法终止或跳出。foreach适用于循环次数未知，或者计算循环次数比较麻烦情况下使用效率更高，但是更为复杂的一些循环还是需要用到for循环效率更高 (2)for in循环通常用来遍历对象。用法为：for (var prop in obj)，其中，prop为对象的属性名，obj为要遍历的对象，obj[prop]即为取出对象的属性值。 for in通常和hasOwnProperty()配合使用，意为先看prop属性是否是对象本身的(该属性不在原型上)，来节约遍历成本。 具体实现代码如下：123456789101112131415function arrFlat (arr) &#123; var newObj = &#123;&#125;; arr.forEach(function (ele, index) &#123; // console.log(ele); //&#123;x: 1&#125; &#123;y: 2&#125; &#123;z: 3&#125; for (var prop in ele) &#123; if(ele.hasOwnProperty(prop)) &#123; // console.log(ele[prop]) //1 2 3 newObj[prop] = ele[prop]; &#125; &#125; &#125;) return newObj;&#125;console.log(arrFlat(arrObj)); //函数调用，打印出结果 上面需要注意的是，如何取到对象的属性名并将对应的属性值赋给他。 这里的处理方法是通过声明一个新的对象，然后通过原来对象的prop取到具体的属性名，即newObj[prop]。ele[prop]取到的为原来对象的属性值。]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找法]]></title>
    <url>%2F2018%2F09%2F03%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分查找法二分查找法也称折半查找法，适用于在已知排列顺序的有序数组查找某个特定元素。 原理：(1)首先，从数组的中间位置开始查找。如果要查找的元素等于中间元素，返回中间元素索引。否则，进行第二步。 (2)如果要查找的元素大于中间元素，则在数组大于中间元素的那半区域进行查找； 如果要查找的元素小于中间元素，则在数组小于中间元素的那半区域进行查找。 然后重复第一步的操作。 (3)如果要查找的元素不存在，则返回-1。 具体实现12345678910111213141516171819function search (data, target) &#123; var start = 0, end = data.length - 1; while (start &lt;= end) &#123; var middle = Math.floor((start + end) / 2); //找到中间元素 if (target === data[middle]) &#123; return middle; &#125;else if (target &gt; data[middle]) &#123; start = middle + 1; &#125;else &#123; end = middle - 1; &#125; &#125; return -1; //要查找的元素不存在&#125;var arr = [1, 5, 2, 7, 13, 2, 3, 4, 34];var result = search(arr, 7); //方法调用console.log(result); //3,返回目标元素的索引]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序法]]></title>
    <url>%2F2018%2F09%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序法在看阮一峰老师的快速排序法时，总能看到网上各种各样的吐槽文章，都说阮老师的实现方法有问题。那么，具体问题到底在哪呢？ 本着学习的心态，查找了一些相关的文章和实现方法，发现大家都是不约而同的采用阮老师的实现方法。我在阮老师的基础上做了一点改进，如下。 原理(1)选基准：选择数组里面的任意一个元素作为基准数(我以中间元素为例)。 (2)划分数组： 小于基准数的元素放在’基准’左边； 大于基准数的元素放在’基准’右边； 等于基准数的元素和’基准’放在一起。 (3)递归：对’基准’左边和右边两个子集，不断重复第一步和第二步，直到所有子集只剩一个元素为止。 具体实现123456789101112131415161718192021222324252627function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; //递归出口，当数组长度小于等于1时返回 return arr; &#125; var temple = Math.floor(arr.length / 2); var flag = arr.splice(temple, 1)[0]; var left = [], middle = [flag], right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; flag) &#123; left.push(arr[i]); &#125;else if (arr[i] &gt; flag) &#123; right.push(arr[i]); &#125;else &#123; middle.push(arr[i]); &#125; &#125; return quickSort(left).concat(middle, quickSort(right));&#125;var arr = [2, 5, 23, 10, 7, 8, 12, 7, 6];var newArr = quickSort(arr);console.log(newArr); //[2, 5, 6, 7, 7, 8, 10, 12, 23] 待排序数组每次调用quickSort方法时，都会被分成左，中，右三个数组。对左边和右边的数组再用相同的方法进行排序，最后返回排序完成的数组。 相关方法：(1) Math.floor() 向下取整 temple = Math.floor(arr.length / 2); 当数组长度为偶数时，刚好取到中间左边的那位，var arr = [2, 5, 23, 10],temple == 5; 当数组长度为奇数时，刚好取到中间的那位，var arr = [2, 5, 4，23, 10],temple == 4; (2) Array.splice(start, length) 从第几位开始删除数组，删除几个长度，直接操作原数组，并返回原数组，数组中的每一项为删除的数据 (3) Array.concat(arr1, arr2, …) 多个数组arr1, arr2和数组Array进行拼接成一个数组，返回拼接完成后的数组 总结我和阮一峰老师快排的不同主要在于多了一个middle数组来接收和’基准’一样的元素。 用递归方法来实现时，需要考虑到每次进行操作时共同点在哪（即找规律，找公式）。 还要考虑到当满足一定条件时跳出（即出口），否则程序将会陷入死循环。]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序和选择排序]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[关于数组的操作，经常会涉及到时间复杂度，空间复杂度，稳定性和不稳定性几个概念。 时间复杂度：一个程序执行所需要的时间，主要针对的是for循环 空间复杂度：程序所需的存储空间，可以估算出内存的大概使用情况 稳定性：如果a = b，a在b的前面，排序后a任然在b的前面 不稳定性：如果a = b，a在b的前面，排序后a在b的后面 具体的归纳情况可以见下图： 数组的排序方法冒泡排序法原理：依次比较数组里面每相邻的两个元素。如果前面的数比后面的数大，则将两个数交换顺序。也就是找到数组的最大数放在最后一位。 重复相同的规律，每次找出剩下数组里面的最大数放在最后面，直到数组有序排列为止。 具体实现(原型链编程)：1234567891011121314151617Array.prototype.bubbleSort = function () &#123; var temple; for (var i = 0; i &lt; this.length - 1; i++) &#123; //this指向被调用的对象 for (var j = 0; j &lt; this.length - 1 - i; j++) &#123; if (this[j] &gt; this[j+1]) &#123; temple = this[j]; this[j] = this[j+1]; this[j+1] = temple; &#125; &#125; &#125; return this;&#125;var arr = [1, 5, 2, 7, 13, 2, 3, 4, 34];var arrSort = arr.bubbleSort(); //方法调用console.log(arrSort); //[1, 2, 2, 3, 4, 5, 7, 13, 34] 需要注意的是，每两个数进行比较大小时，知道第n - 1个数，则可以比较出第n - 1个数和第n个数的大小。所以第一个for循环终止条件为arr.length - 1。 第二个for循环时，当i = 0时，需要循环的次数为arr.length - 1,第一次循环结束的结果是选出最大的数放在数组最后，即排序后的数组为[1, 2, 5, 7, 2, 3, 4, 13, 34]。 当i = 1时，循环次数为arr.length - 1 - 1，即最后一个数已经确定大小，不需要比较。还有余下数组的最后一位也不需要比较。 当然啦，这样做是为了节省时间复杂度，当两圈for循环的终止条件改为arr.length也是可以的。 选择排序原理：选择排序是指选出数组里面的第一个数依次和后面的每个数作比较，如果后面的数比第一个数小，交换顺序（选出最小的数放在第一位）。 再选出第二个数依次和后面的每个数作比较，选出余下数组里面最小的放在第二位。 重复以上规律，知道数组有序为止。 具体实现：12345678910111213141516Array.prototype.selectSort = function () &#123; for (var i = 0; i &lt; this.length - 1; i++) &#123; //this指向被调用的对象 for (var j = i + 1; j &lt; this.length; j++) &#123; if (this[i] &gt; this[j]) &#123; temple = this[i]; this[i] = this[j]; this[j] = temple; &#125; &#125; &#125; return this;&#125;var arr = [1, 5, 2, 7, 13, 2, 3, 4, 34];var arrSelect = arr.selectSort(); //方法调用console.log(arrSelect); //[1, 2, 2, 3, 4, 5, 7, 13, 34] 冒泡排序和选择排序的区别比较冒泡排序和选择排序，发现他们其实实现原理都是一样的。 区别在于，冒泡排序是每两个相邻元素作比较，每次排序的结果是选出当前数组中的最大元素放在数组最后。选择排序是第一个元素依次和后面的每个元素比，选出最小的元素放在数组第一位。依次重复类推。 冒泡排序是先确定最大元素放在最后，选择排序先确定最小元素放在第一位，所以他们最终的结果都是数组里面的数升序排列。]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[数组去重数组去重是后续经常会用到以及面试中经常用到的知识点，最近在复习中整理了以下几种方法仅供大家参考。 原生方法原理：建立一个新数组，取出原数组的每一项和新数组的每一项作对比，将原数组中存在而新数组中不存在的元素添加到新数组中，最后返回新数组 具体实现（原型链上编程）：12345678910111213141516171819Array.prototype.unique = function () &#123; var newArr = [this[0]]; //谁调用的unique方法，this指向谁（arr) for (var i = 0; i &lt; this.length; i++) &#123; var flag = true; for (var j = 0; j &lt; newArr.length; j++) &#123; if (this[i] === newArr[j]) &#123; flag = false; &#125; &#125; if (flag) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 需要注意的是：1.第二个for循环遍历的次数为newArr.length，如果newArr为空，则不会进入for循环，将不会执行后面的语句。 2.第二个for循环里不能只是简单的根据条件判断arr[i] !== newArr[j]便试图直接调用newArr.push(arr[i])的方法来进行添加。 试想一下，当数组arr遍历到第3位(即1)时，此时newArr == [1, 2]，newArr.length == 2；进入第二个for循环中，循环次数为2。 第一次循环时arr[i] === newArr[j] (即1 == 1)，不会进入if循环；第二次arr[i] !== newArr[j] (即1 != 2)，进入if语句，执行push语句，所以会再次向newArr中添加1，返回newArr = [1, 2, 1],以此类推。 即以下写法是错误的：1234567for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; newArr.lenght; j++) &#123; if (arr[i] !== newArr[j]) &#123; newArr.push(arr[i]); &#125; &#125;&#125; 利用对象的属性名无重复原理：对象的属性名是没有重复的，取出数组的每一位，看对象里面是否存在（即取出对象的属性名，看对应的属性值是否存在。如果不存在，则证明对象中没有这个属性，该元素在数组中是第一次出现，并将该元素添加到新数组中）。此时需要给不存在的属性赋值做标记 具体实现：123456789101112131415Array.prototype.unique = function () &#123; var obj = &#123;&#125;; var newArr = []; for (var i = 0; i &lt; this.length; i++) &#123; if(!obj[this[i]]) &#123; obj[this[i]] = 1; newArr.push(this[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 调用splice()删除重复元素原理：取出数组中的每一个元素依次和后面的每一个元素对比，如果后面的元素有相同的则为重复元素，删除该元素 相关方法：splice(start, length) 从第几位开始删除数组，删除几个长度，直接操作原数组，并返回原数组，数组中的每一项为删除的数据 slice(start, end) 截取数组的start位到end位（但不包括end位）的值，返回一个新数组。原数组不改变 具体实现：1234567891011121314Array.prototype.unique = function () &#123; for (var i = 0; i &lt; this.length; i++) &#123; //谁调用的unique方法，this指向谁（arr) for (var j = i + 1; j &lt; this.length; j++) &#123; if (this[i] === this[j]) &#123; this.splice(j, 1); &#125; &#125; &#125; return this;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] indexOf()找出符合条件的第一个原理：根据indexOf()来判断该元素是否是第一次出现，即看当前元素的索引值是否是满足条件的第一个索引值。 相关方法：Array.indexOf(item): 返回item元素在当前数组中第一次出现的索引值，不存在则返回-1。 具体实现：123456789101112Array.prototype.unique = function () &#123; for (var i = 0; i&lt; this.length; i++) &#123; if(this.indexOf(this[i]) !== i) &#123; this.splice(i, 1); &#125; &#125; return this;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] filter()按一定规则遍历数组原理：用filter来遍历生成满足条件的新数组，判断的条件需要借助indexOf()来判断当前元素的索引是否等于当前的索引 相关方法：filter(item, index, array) 有三个参数，第一个为数组的每一项(相当于arr[i])，第二个为当前元素的索引(i)，第三个为原来的数组(即调用filter的那个数组)。 该方法会返回一个满足条件的新数组。 具体实现：12345678910Array.prototype.unique = function () &#123; var newArr = this.filter(function (item, index, array) &#123; return array.indexOf(item) === index; &#125;) return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 2, 13, 3, 4, 34] 看到这里相信你应该已经明白，filter()方法就相当于for循环的封装，本质上还是取出数组中的当前项和当前索引，看该元素的索引值是不是第一次出现 sort()先排序，再去重原理：先将数组进行排序，相同的数据会排列在一起。 所以进行数组去重时只需要将当前数据与前一个数据作对比。如果当前数据不等于前一个数据，则说明该数据是第一次出现。 可以利用一个新数组，每次将数据添加到新数组时，通过判断当前的数据与新数组的最后一位是否相等。如果不相等，则将该数据push到新数组。 相关方法：Array.sort() 默认将数组按照ASCII进行排序。 当里面传入一个回调函数时，即Array.sort(function (a, b) {return 1;})为升序排列；当return -1时为降序排列。 具体实现：1234567891011121314Array.prototype.unique = function () &#123; this.sort(); var newArr = []; for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] !== newArr[newArr.length - 1]) &#123; newArr.push(this[i]); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var uniqueArr = arr.unique(); //方法调用console.log(uniqueArr); //[1, 13, 2, 3, 34, 4] 从结果可以看到，返回的数组根据ASCII升序排列。 Set()数据结构原理：调用ES6中的Set数据结构可以用于数组去重 具体实现：123var arr = [1, 1, 2, 1, 13, 2, 3, 4, 34];var setArr = new Set(arr);console.log(setArr); 结果：]]></content>
      <categories>
        <category>数组的操作</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历]]></title>
    <url>%2F2018%2F08%2F15%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[参考文献：https://www.cnblogs.com/attitudeY/p/6790219.html和https://blog.csdn.net/zhouziyu2011/article/details/62236006 树树状图是一种数据结构，把他叫做树是因为他像一棵倒挂的树，根朝上，叶朝下。大概结构如下：图片来源：点击查看 你所看到的每个元素叫做一个节点，一棵树可以有多个节点。 特殊的是，二叉树的节点不超过两个。最上面的没有父节点的（23）称为根节点，以根节点为分界点，可以把二叉树树分为左子树和右子树，如上图。二叉树常被用于实现二叉查找树和二叉堆。 二叉树的遍历深度优先遍历对于一棵二叉树，深度优先遍历是沿着树的深度遍历树的节点层数，尽可能深的搜索树的分支，其中，每个节点只能遍历一次。 深度优先遍历分为先序遍历，中序遍历，后序遍历。先序遍历：对任意子树，先访问根，然后遍历其左子树，最后遍历右子树。中序遍历：对任意子树，先遍历其左子树，然后访问根，最后遍历右子树。后序遍历：对任意子树，先遍历其左子树，然后遍历右子树，最后访问根。 广度优先遍历广度优先遍历又叫宽度优先搜索或横向优先搜索，是从根节点开始沿着树的宽度一层层的往下遍历，在每一层中，从左往右（或从右往左）访问每一个节点，访问完一层就进入下一层，直到找到最后一层。 请看下面例子：先序遍历：35 20 15 16 29 28 30 40 50 45 55中序遍历：15 16 20 28 29 30 35 40 45 50 55后序遍历：16 15 28 30 29 20 45 55 50 40 35广度优先遍历：35 20 40 15 29 50 16 28 30 45 55 深度优先和广度优先的区别深度优先：二叉树的深度优先遍历采用的是栈。深度优先遍历二叉树是先访问根节点，然后访问左子树，接着访问右子树。根据栈先进后出的原则，我们可以先将右子树压栈，然后将左子树压栈，这样左子树就位于栈顶，可以永远保证左子树先于右子树被访问到。 深度优先搜索不全部保留节点，拓展完的节点从数据库中弹出删去。这样，一般在数据库中存储的节点就是深度值，因此他占用空间少。适用于搜索树节点较多时。 广度优先：广度优先遍历采用的是队列。一般需存储产生的所有节点，占用的存储空间比深度优先搜索大的多。因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先算法没有出栈入栈的操作，运行速度比深度优先搜索快。 算法实现深度优先遍历递归实现123456789101112function dfs (node) &#123; var nodes = []; if (node !== null) &#123; nodes.push(node); var children = node.children; var len = children.length; for (var i = 0; i &lt; len; i++) &#123; dfs(children[i]); &#125; &#125; return nodes;&#125; 深度优先遍历非递归实现1234567891011121314151617function dfs (node) &#123; var nodes = []; if (node !== null) &#123; var stack = []; stack.push(node); while (stack.length !== 0) &#123; var item = stack.pop(); nodes.push(item); var children = item.children; var len = children.length; for (var i = len - 1; i &gt;= 0; i--) &#123; stack.push(children[i]); &#125; &#125; &#125; return nodes;&#125; 广度优先遍历递归实现1234567891011function bfs(node) &#123; var nodes = []; var i = 0; if (!(node == null)) &#123; nodes.push(node); bfs(node.nextElementSibling); node = nodes[i++]; bfs(node.firstElementChild); &#125; return nodes;&#125; 广度优先遍历非递归实现123456789101112131415function bfs(selectNode) &#123; var nodes = []; if (selectNode != null) &#123; var queue = []; queue.unshift(selectNode); while (queue.length != 0) &#123; var item = queue.shift(); nodes.push(item); var children = item.children; for (var i = 0; i &lt; children.length; i++) queue.push(children[i]); &#125; &#125; return nodes;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构，二叉树，深度优先，广度优先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[z-index]]></title>
    <url>%2F2018%2F08%2F14%2Fz-index%2F</url>
    <content type="text"><![CDATA[我曾经遇到过这样一个面试题，a和b为兄弟结构标签，c为a的子标签，当a标签的z-index为1，b为2，c为3时，页面该如何布局？1234567891011121314151617181920212223242526272829303132&lt;div class=&apos;a&apos;&gt;a &lt;div class=&apos;c&apos;&gt;c&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;b&apos;&gt;b&lt;/div&gt;&lt;style&gt; .a, .b &#123; width: 100px; height: 100px; &#125; .a &#123; position: absolute; z-index: 1; background: green; &#125; .b &#123; position: absolute; top: 60px; left: 60px; z-index: 2; background: blue; &#125; .c &#123; position: absolute; top: 20px; left: 20px; z-index: 3; width: 60px; height: 60px; background: orange; &#125;&lt;/style&gt; 你想到该如何布局了吗？ 跟浮动不一样的是，z-index是将元素抽离到更高层面进行定位，并不会影响到他原来的布局(在具有z-index属性后面的元素仍然是从z-index元素占据的开始位置进行布局，并保持着原来的特性和方式进行布局)。 z-index默认值为0，当多个元素具有z-index属性时，数字越大的显示时越在上面。 但要考虑到的一个情况是：如果父元素和子元素同时具有z-index属性时，要优先考虑父元素的z-index。即使子元素的z-index比父元素大，实际显示时也是以父元素的为准。父元素包裹着子元素，将子元素的z-index降为和父元素保持一致。 W3C 对 z-index 属性的描述中提到在 z-index 属性仅在节点的 position 属性为 relative, absolute 或者 fixed 时生效。 浏览器实际展示效果如下：c为a的子元素，但父级a具有z-index属性，以父元素为准，所以a和c的z-index都为1，b的z-index为2，所以b在最上面 想象一下，在三维坐标轴中，z轴代表物体的高度，当给物体加上z-index属性时，物体就具有了空间感，就能根据z-index对物体进行定位。 情形1：上面提到的是，z-index后面的元素会依照元素的性质从z-index元素占据的开始位置进行布局显示，于是我在具有z-index属性的元素后面添加了一些元素，来查看页面的布局到底是怎样的？ 修改后的代码如下：123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=&apos;a&apos;&gt;a &lt;div class=&apos;c&apos;&gt;c&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;b&apos;&gt;b&lt;/div&gt;&lt;span&gt;sssssssssggggggssssssrrrrrrrrr&lt;/span&gt;&lt;div class=&apos;content&apos;&gt;&lt;/div&gt;&lt;style&gt; .a, .b &#123; width: 100px; height: 100px; &#125; .a &#123; position: absolute; z-index: 1; background: green; &#125; .b &#123; position: absolute; top: 60px; left: 60px; z-index: 2; background: blue; &#125; .c &#123; position: absolute; top: 20px; left: 20px; z-index: 3; width: 60px; height: 60px; background: orange; &#125; .content&#123; width: 170px; height: 170px; background: #555; &#125;&lt;/style&gt; 浏览器中显示如下： 情形2：当父元素和子元素同时具有z-index属性时，会优先考虑父元素的z-index并以父元素为准。但当父元素没有z-index属性时，页面是否会根据z-index的数值大则在最上面排列来进行显示呢？ 修改最开始的代码，去掉父级a的z-index属性，此时具有z-index的只有子级c和元素b, c的z-index为3，b为2，此时页面会怎么显示呢？ 浏览器中显示情况： 情形3：对于同样的元素，当页面中直接没有z-index属性时，又该如何显示呢？ 修改代码，去掉所有的z-index属性，查看页面显示。 可以看到的是，此时页面显示和一开始元素都具有z-index属性时一致。这只是因为每个元素都具有position属性，具有position属性的元素会根据给元素设置的位置进行定位显示。 position: absolute;绝对定位。b此时会根据浏览器进行定位显示，再因为b元素排列在a元素后面，所以b元素会排列在最上层，于是就有了如图所示的显示。 对于同样的标签，当给他设置的是浮动属性而不是z-index时，将会发生什么呢？ 同样的，改变z-index为float，代码如下：12345678910111213141516171819202122232425&lt;div class=&apos;a&apos;&gt;a &lt;div class=&apos;c&apos;&gt;c&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;b&apos;&gt;b&lt;/div&gt;&lt;style&gt; .a, .b &#123; width: 100px; height: 100px; &#125; .a &#123; float: left; background: green; &#125; .b &#123; float: left; background: blue; &#125; .c &#123; float: left; width: 60px; height: 60px; background: orange; &#125;&lt;/style&gt; 浏览器中展示如下：具有浮动属性的元素将会脱离正常的文档流，被抽离到更高层面进行定位，所以a和b并排在一起，a里面包裹着他的子元素c。]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>浮动</tag>
        <tag>z-index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于元素的bfc]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%85%B3%E4%BA%8Ebfc%E5%8F%8A%E7%94%A8%E9%80%94%2F</url>
    <content type="text"><![CDATA[bfc–块级格式化上下文具有bfc特性的元素可以看做是隔离了的独立容器。容器里面的元素无论怎样变化，都不会在布局上影响到外面的元素，并具有普通元素没有的特性。 能够触发bfc特性的以下任意一个条件均能触发元素的bfc属性：(1)float: left / right(除none);(2)overflow: hidden / auto / scroll(除visible);(3)position: absolute / fixed; (4)display: inline-block / flex / inline-flex / table-cell /table-caption;(5)根标签body; bfc的用途I.清除浮动当给子级元素设置浮动属性时，需要给父级清除浮动。浏览器呈现的情况如下：代码如下：1234567891011121314151617181920&lt;div class=&apos;wrapper&apos;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; background: green; border: 2px solid #000; margin-top: 200px; &#125; .wrapper div &#123; float: left; margin: 30px; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 可以看到，父级包不住子级的div元素，需要给父级清除浮动触发父级的bfc，使其回到正常的文档流。 清除浮动的方法：123456789101112131415161718192021&lt;div class=&apos;wrapper&apos;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrapper &#123; display: inline-block; background: green; border: 2px solid #000; margin-top: 200px; &#125; .wrapper div &#123; float: left; margin: 30px; width: 100px; height: 100px; background: orange; &#125;&lt;/style&gt; 清除浮动后的样式:这里是通过给父级添加属性’display: inline-block’来实现，你也可以通过其他方法试一试。 II.解决margin塌陷请看下面情况：此时明明给父级和子级都设置了margin-top，但是浏览器所展现出来的只有父级的margin-top。 代码如下：123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 150px; height: 150px; background: orange; &#125;&lt;/style&gt; 这里涉及到盒子模型的概念。盒子模型的组成包括margin + border + padding + content。其中，在此提到的margin为复合属性，包括margin-top, margin-right, margin-bottom, margin-left。浏览器后台的盒子模型如下： margin塌陷指的是margin-top，针对的是具有父子结构嵌套的元素。 解决margin塌陷的方法1如果想要父级子级的margin-top都能正常的显示，此时只需要触发父级元素的bfc属性。12345678910111213141516171819&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; overflow: hidden; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 150px; height: 150px; background: orange; &#125;&lt;/style&gt; 修改后的展示如下： 上面是通过给父级添加overflow: hidden的属性来实现的，用overflow: hidden的缺点就是：如果子级元素大于父级元素时，子级多出父级元素的部分会被隐藏。 当子级溢出部分没有被隐藏时，实际展示效果如下： 此时和上面不同的只是使子级元素的宽度大于父级，多出的部分会超出父级正常显示。123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 给父级设置overflow：hidden属性后，浏览器显示如下：相应代码如下：12345678910111213141516171819&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; overflow: hidden; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 100px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 此时虽然能解决margin塌陷带来的坏处，但是却使子级多出父级的部分溢出隐藏，如果想要使子级多出的部分正常显示，就可以采取其他的方法来触发元素的bfc属性。 解决margin塌陷的方法2通过计算解决：当子级元素的margin-top大于父级时，实际展示效果将以子级的margin-top为准，子级会带动父级一起向下运动。123456789101112131415161718&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .father &#123; margin-top: 200px; width: 260px; height: 260px; background: green; &#125; .son &#123; margin-top: 300px; width: 300px; height: 150px; background: orange; &#125;&lt;/style&gt; 以上代码通过计算来解决margin塌陷，实际上在浏览器中最终所展示的margin-top为300px,而且不会影响到子级元素的大小。]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>浮动</tag>
        <tag>bfc</tag>
        <tag>margin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello MyBlog]]></title>
    <url>%2F2018%2F07%2F08%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[这是我搭建好博客后的第一篇文章，一切都会有个好的开始。 我是一个前端的小菜鸟，可能很多东西理解的也不太对，欢迎大家留言指正。 搭建博客博客基础这里主要借助的是 GitHub + Hexo 来进行搭建博客。 可能你也像我一样是技术小白，可能你也正为如何搭建博客而烦恼，如果你想新建属于自己的博客，点击 这里 查看。 博客主题样式配置如果你想更换博客主题,配置自己喜欢的样式,点击 这里 查看。 上传本地博客相信看到这里的你已经按照以上的步骤配置好了属于自己的博客,此时博客只是在本地运行的,想要让本地博客能在浏览器里访问，快借助GitHub来进行配置吧！主要方法(在cmd工具栏中进入搭建博客的本地文件夹，输入如下命令)：1$ hexo g 1$ hexo d 具体可以参照 这里 来进行配置！ 新建文章新建页面配置好所有的环境之后，就可以在本地编辑器里写自己的博客内容了。首先，当然是要新建博客写作页面了。在hexo里面有三种新建的方式。在cmd里执行以下命令：1$ hexo new [layout] &lt;title&gt; 其中，layout为新建的位置，包含以下三个值：布局—————-路径post—————source/_posts (一般新建单个博客页面时使用)page—————source (用来配置和引入资源,包括图片,以及在搭建博客时的标签,分类页)draft—————source/_drafts (新建草稿)举个栗子:1$ hexo new post hello,hexo 1$ hexo new page tags 现在，你可以找到source文件夹查看具体区别。 配置参数每新建好一个文件，你可以看到最上面有用--- ---来隔开一个部分，这是用来进行参数匹配的。 在本篇博客里，我的配置是这样的：1234567---title: Hello MyBlogdate: 2018-07-08 09:58:00tags: [hexo,blog,essay]categories: 搭建博客comments: true--- 其中，tags和categories参数你需要先建立页面1$ hexo new page tags 1$ hexo new page categories 并在source文件夹下找到对应的tags页面，配置以下参数：12345---title: tagsdate: 2018-07-07 13:23:03type: &apos;tags&apos;--- 同理，在categories页面中配置：12345---title: categoriesdate: 2018-07-08 21:21:28type: &apos;categories&apos;--- 到这里，页面基本参数就配置好了，接下来主要就是要发布的博客内容。 文章标题一级标题：&lt;h1&gt;&lt;/h1&gt; –表示方法：# 名称二级标题：&lt;h2&gt;&lt;/h2&gt; –表示方法：## 名称三级标题：&lt;h3&gt;&lt;/h3&gt; –表示方法：### 名称一般我们标题都是用来语义化表示题目内容的，不宜嵌套太深，主要常用的就是前三级标题 网址链接表示方式：1[要显示的内容](与该内容相关的网址) 1[这里](https://www.jianshu.com/p/9d1b865217a5) 其他内容就正常书写就好啦！ 上传博客内容写到这里本篇博客内容页该结束啦！此时想要把本地写好的博客内容上传到浏览器里查看，只要执行以下代码就可以啦！开心~~~12$ hexo g$ hexo d 具体内容可以点击 这里 查看hexo官方文档]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
